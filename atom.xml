<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小客栈</title>
  
  <subtitle>Live Laugh Love</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-12-31T14:45:02.465Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>CouriourC</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端的B 端设计思维</title>
    <link href="http://example.com/posts/37JRPY2.html"/>
    <id>http://example.com/posts/37JRPY2.html</id>
    <published>2024-12-31T14:45:02.465Z</published>
    <updated>2024-12-31T14:45:02.465Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="以习惯为本的设计"><a class="markdownIt-Anchor" href="#以习惯为本的设计"></a> 以“习惯”为本的设计</h2><img src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgZGF0YS1kaWFncmFtLXR5cGU9Ik1JTkRNQVAiIGhlaWdodD0iNzhweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjI4NXB4O2hlaWdodDo3OHB4O2JhY2tncm91bmQ6I0ZGRkZGRjsiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDI4NSA3OCIgd2lkdGg9IjI4NXB4IiB6b29tQW5kUGFuPSJtYWduaWZ5Ij48ZGVmcy8+PGc+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjgwLjQ1IiB4PSIxMCIgeT0iMjAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSIyMCIgeT0iNDIuOTk1MSI+JiMyOTk5MjsmIzI1MTQzOyYjMjAzMDc7JiMzOTU2NDs8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTI1Ljk5OTUiIHg9IjE0My40NSIgeT0iMjQuNjk4MiI+JiMzMTUyNjsmIzIxNTEyOyYjMjk5OTI7JiMyNTE0MzsmIzI1ODA1OyYjMjAzMTY7JiMzMDM0MDsmIzIwMTMyOyYjMjAxMTQ7PC90ZXh0PjxwYXRoIGQ9Ik05MC40NSwzOC4xNDg0IEwxMDAuNDUsMzguMTQ4NCBDMTE1LjQ1LDM4LjE0ODQgMTE1LjQ1LDE5Ljg1MTYgMTMwLjQ1LDE5Ljg1MTYgTDE0MC40NSwxOS44NTE2ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY5Ljk5OTciIHg9IjE0My40NSIgeT0iNDIuOTk1MSI+JiMyMDQxNTsmIzI1NDYzOyYjMzAzNDA7JiMyNTgwNTsmIzIwMzE2OzwvdGV4dD48cGF0aCBkPSJNOTAuNDUsMzguMTQ4NCBMMTAwLjQ1LDM4LjE0ODQgQzExNS40NSwzOC4xNDg0IDExNS40NSwzOC4xNDg0IDEzMC40NSwzOC4xNDg0IEwxNDAuNDUsMzguMTQ4NCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSIxNDMuNDUiIHk9IjYxLjI5MiI+JiMzMDAyODsmIzM4NzU0OyYjMTk5Njg7JiMzMzI2ODs8L3RleHQ+PHBhdGggZD0iTTkwLjQ1LDM4LjE0ODQgTDEwMC40NSwzOC4xNDg0IEMxMTUuNDUsMzguMTQ4NCAxMTUuNDUsNTYuNDQ1MyAxMzAuNDUsNTYuNDQ1MyBMMTQwLjQ1LDU2LjQ0NTMgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7Ii8+PCEtLVNSQz1bVFBIMVF6SDA1Q1ZGcGdTT3lEOE1NaEZQRERjcUlvYmpqTDJ0TUFvakh2ZDlsQUozOWZEYlRoQkJLV2VVMTdqZUdRblVIMnlZOGs5SGcxSWdOc1Jqc2NfWFI5OWJMdmJDSmlkeHBWa19VVmRGTS15ZzhiTjIxS2o4MXBNeFFYMzM2WWhWanBZOTk0ZG1DUmdwOTg3WHVtcUlqMkVQUGU5amZkNGd5THJPVGZYWmh2d2lRWUFMSDRIV1dDQXdIc2tpVzBPR25zZFYxNTdBaDRRUEFVT3pLdzg2Mnpud00zMkgxMTA2Zmt4SlBPU0tKMzBXOWdHTUs0Z1QwZzVuUGJBb2g0T2pCOUt3Y1VwNDlpWnJqOVhSRzBkOVoyTnhXVXJJZ3FwNEhUbEtHd2xrLXJ2UFphcHhmZkI5aVhRUmRkbldRZXhkLXdHLUVQTUVjZmdKaHU5WEhCUXQ5SjZiU2xDcktKQ1k5NXliU2ZIc3JUQ1poZW1fbHBQLTJoMVZuVUloT0JKRk1abXdLV1FBQ0NoeU1RekxXR25TUGlfd2hHZzRxMHZXbmRDTDczSDJQd0FTLXd3Mk9ydmVDSmhyTlhMY3d2UE9LX3pMTzQ0MHhoeVVoMmdsRFhRVXlNNExIdmEzdVRJQkxMdG5jR1RhbmV6THdQV01kZFBiSzhMdkcyNl9fSVVlVVF5U0M2VzFaenZ5a0pjejc1dlZ0N3V6bXFZRUQtQ2tQdTBNNWZ4WHFSVkZsci1UNWlaRG5WZG0tbHRldE9sWHJRVlhyTWxTUjFSVE01bEJxVTdGTnBWZGJwZlNTRi03SHNfRlJaenk3RnZ1X2tWYnp6ZE9Fa1dITHV1emoxU0plR3ZzTXhXN2lpakpXTWpCamNLeElwdTVIVG92MHo0TXV0aVBmNGM3d3I2V1UwQnBRNnZ4aHVNeFFJTzNtOG50YlVHcUt0aHBGRGVYRk84VlBzQkNoVTE3N0gweE1teWQ3XzF6cVVDbzVHYThYTk9FVHdVMHdvbmtTOE50R1Vlb3lFNGtzZUFHUEI3SUV1QUtTSDZqdThDZDNuT1JnQU5EZHY1OHZtUTFEZE1sYkhwZXNGdlZdLS0+PC9nPjwvc3ZnPg=='><p><strong>B 端</strong>产品相对于<strong>C 端</strong>产品更加注重用户交互，一般 B 端用户对于界面的要求并不高，<strong>习惯就好</strong>。那么 <strong>B 端</strong>中的以人为本又是什么意思呢？ 其实对于 B 端使用很多细节其实是在抠&quot;<strong>习惯</strong>&quot;，可以说一款适合用户习惯的设计，就是一个合理的产品了。</p><h3 id="逻辑清晰的设计"><a class="markdownIt-Anchor" href="#逻辑清晰的设计"></a> 逻辑清晰的设计</h3><h4 id="原则一清楚数据如何来去到哪儿"><a class="markdownIt-Anchor" href="#原则一清楚数据如何来去到哪儿"></a> 原则一：清楚数据如何来，去到哪儿</h4><p>操作逻辑必须是保证贯通的，当用户对某一个步骤产生，“这个数据是怎么来的？”，这种问题的时候，毫无疑问，这个设计是失败的。甚至在自己开发的时候都产生疑问: 这堆数据究竟<strong>TMD</strong>是怎么来的🤡。</p><p>在前端开发时，应该注意在代码编排的时候，请求与鉴定顺序应该是一致的。下面是一种流程编排的思考方式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一种函数式的数据编排模式</span></span><br><span class="line"><span class="title function_">task</span>(<span class="string">&quot;submit-form&quot;</span>) <span class="comment">// 设定任务集，代表这个是什么流程</span></span><br><span class="line">.<span class="title function_">load</span>(formData) <span class="comment">// 填入数据</span></span><br><span class="line">.<span class="title function_">pipe</span>(selfCheck) <span class="comment">// 数据提交前的预检查</span></span><br><span class="line">.<span class="title function_">wait</span>(submitForm) <span class="comment">// 提交数据表，等待数据请求完成</span></span><br><span class="line">.<span class="title function_">pipe</span>(fallback) <span class="comment">// 请求成功结果的反馈</span></span><br><span class="line">.<span class="title function_">pipe</span>(...) <span class="comment">// 其他的并行请求，实现方式可以参考 gulp 的实现</span></span><br><span class="line">.<span class="title function_">pipe</span>(norimalize) <span class="comment">// 将返回的数据人性化处理[见后文，原则三]</span></span><br></pre></td></tr></table></figure><p>还有一些额外的交互细节，比如防抖节流，加载加锁等。</p><h4 id="原则二不存在无关或不可用的控件"><a class="markdownIt-Anchor" href="#原则二不存在无关或不可用的控件"></a> 原则二：不存在无关或不可用的控件</h4><p>一个页面中，不应该存在不可用的控件，每一个控件存在一定有它的意义。若是无用的控件放置在页面，会让用户认为自己被戏耍，或者认为页面出错了。</p><p>开发的时候经常会碰到，第二天就要上线了，但是还有部分功能处于开发中，或者还处于安排了，但是处于待定状态，可能很多时候会整一个 <code>disabled</code> 给用户，然后置灰，或者抛错，这是没有意义的，这可以说是滥竽充数了。可以考虑 <code>stash</code> 一个功能点，然后逐步 <code>push </code>，一部分一部分来。</p><h4 id="原则三-及时有用的反馈"><a class="markdownIt-Anchor" href="#原则三-及时有用的反馈"></a> 原则三 ：及时有用的反馈</h4><p>B 端产品往往涉及到许多的表单，也就不可避免的考虑有效值的输入限制了，最好的控制方法就是，<strong>提前的预警+有效的拦截</strong>，当用户输入不可用的数据时，应该提供警告，甚至是给出最优建议值。</p><h5 id="提前的预警"><a class="markdownIt-Anchor" href="#提前的预警"></a> 提前的预警</h5><p>用户总是不可信任的，对于数据的预检是很重要的，否则很容易流入脏数据，为了系统安全往往会引入数据校验，我们开发过程中，往往是以用户点击提交之后，才对数据进行校验，这使得用户在填完信息之后，才发现这个数据不能用。这是不靠谱的，我们应该提前把一些比如手机号格式校验，邮箱校验，有效值校验，在失去焦点之后，立即进行督促，并且一步步引导用户完成表单提交。</p><h5 id="有效的拦截"><a class="markdownIt-Anchor" href="#有效的拦截"></a> 有效的拦截</h5><p>!<a class="backlink">/media/Pasted image 20230703173601.png</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一种表单校验设计方案</span></span><br><span class="line"><span class="keyword">const</span> form = &#123;</span><br><span class="line"><span class="attr">username</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="attr">password</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="attr">email</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="comment">// 增加冗余字段</span></span><br><span class="line"><span class="attr">_pass</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">_reason</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="title function_">check</span>(<span class="params"></span>)&#123; </span><br><span class="line"><span class="comment">// 争对有效值及时的校验</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_">valid</span>(email)) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_pass</span>  = <span class="literal">false</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_reason</span> = <span class="string">&quot;email not valid&quot;</span>.<span class="property">tr</span>; <span class="comment">// tr 表示国际化后的文字，只做演示</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 争对当前表单的校验</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">username</span>) &#123;</span><br><span class="line"><span class="comment">// 进行轻提示</span></span><br><span class="line"> <span class="title class_">Message</span>.<span class="title function_">error</span>(<span class="string">&quot;please input username&quot;</span>.<span class="property">tr</span>) ;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useSubmit</span>(<span class="params">form</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (!form?.<span class="property">check</span>?.()) <span class="keyword">return</span>; <span class="comment">// 提前预检</span></span><br><span class="line"><span class="title function_">call</span>(<span class="variable language_">this</span>,<span class="title function_">task</span>(<span class="string">&quot;submit-task&quot;</span>)); <span class="comment">// 执行提交任务,这里具体如何都行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="习以为常的快捷键"><a class="markdownIt-Anchor" href="#习以为常的快捷键"></a> 习以为常的快捷键</h3><h4 id="原则五-不覆盖用户常用的快捷键"><a class="markdownIt-Anchor" href="#原则五-不覆盖用户常用的快捷键"></a> 原则五 ：不覆盖用户常用的快捷键</h4><p>有一些历史悠久的操作快捷键，比如回车搜索，<code>Ctrl+ C|V</code> 系列的快捷键，尤其是对于富文本编辑，这个十分重要，这些对于大部分用户都已经习以为常，若是突然没了，或者改变了，会带来很多奇怪的操作。</p><p>常用的快捷方式，<code>ctrl+s &lt;保存&gt;</code>，<code>enter &lt;搜索&gt;</code> ，<code>ctrl+shift+v &lt;格式粘贴&gt;</code>，<code>ctrl+z</code> ……</p><p>为了便于精细化快捷操作设计，可以抽离到组件，或者直接使用指令实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;shortcut description=&quot;快捷键描述信息&quot; :shortcut=&quot;&#123;</span><br><span class="line">  &#x27;CTRL+Z&#x27;: revoke,</span><br><span class="line">  &#x27;CTRL+S&#x27;: save</span><br><span class="line">&#125;&quot; &gt;</span><br><span class="line">&lt;!-- or like this --&gt;</span><br><span class="line">&lt;input v-shortcut.ctrlB=&quot;Bold&quot; /&gt; </span><br><span class="line">&lt;/shortcut&gt;</span><br></pre></td></tr></table></figure><h3 id="操作的容错性"><a class="markdownIt-Anchor" href="#操作的容错性"></a> 操作的容错性</h3><blockquote><p>“当用户错误地选择了的某个功能后，系统需要提供一个明确的「紧急出口」，来让用户离开这个不想要的状态，无需额外的对话。支持撤销和重做”。——雅各布·尼尔森（Jakob Nielsen）</p></blockquote><p>当用户选择一个错误的操作之后，应该给予一个明确的<strong>后悔窗口</strong>，</p><h4 id="可撤回可反馈"><a class="markdownIt-Anchor" href="#可撤回可反馈"></a> 可撤回可反馈</h4><p>可撤回的形式有很多种，典型的表现为在消息完成提示时候，提供一个撤回按钮，还有一种就是回收站的形式。</p><p>可反馈就很好理解了，就是我们常说的客服反馈。</p><h4 id="不可逆操作给予警示"><a class="markdownIt-Anchor" href="#不可逆操作给予警示"></a> 不可逆操作给予警示</h4><h3 id="设计一致性"><a class="markdownIt-Anchor" href="#设计一致性"></a> 设计一致性</h3><p>设计上下文的风格应该是一致的，基本的圆角，配色风格，排版整齐。入口统一，这样有利于用户养成“<strong>好习惯</strong>”，从而避免误操作带来不可预料的错误。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;以习惯为本</summary>
      
    
    
    
    <category term="公司经历以及问题记录" scheme="http://example.com/categories/%E5%85%AC%E5%8F%B8%E7%BB%8F%E5%8E%86%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="项目中问题记录" scheme="http://example.com/categories/%E5%85%AC%E5%8F%B8%E7%BB%8F%E5%8E%86%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="过度思考" scheme="http://example.com/categories/%E5%85%AC%E5%8F%B8%E7%BB%8F%E5%8E%86%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/%E8%BF%87%E5%BA%A6%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>IE11 下的各类兼容问题以及 Hack 方案</title>
    <link href="http://example.com/posts/CKR7QD.html"/>
    <id>http://example.com/posts/CKR7QD.html</id>
    <published>2024-12-31T14:45:02.463Z</published>
    <updated>2024-12-31T14:45:02.463Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="css"><a class="markdownIt-Anchor" href="#css"></a> CSS</h2><ul><li>postcss-pxtorem 转换是默认浏览器font-size为 10 或者 12,于是在IE中比例过小，导致 1px 无法正常显示。</li></ul><h3 id="组件"><a class="markdownIt-Anchor" href="#组件"></a> 组件</h3><ul><li>实现自适应的八边形渐变背景，（无 <code>clip-path</code>）。<br />动态获取插槽元素的宽高，然后绘制 Svg 作为背景。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;css&quot;&gt;</summary>
      
    
    
    
    <category term="项目中问题记录" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="开发Bug" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%BC%80%E5%8F%91Bug/"/>
    
    
  </entry>
  
  <entry>
    <title>ElmentUI-Uploader-Bug</title>
    <link href="http://example.com/posts/7EEBVC.html"/>
    <id>http://example.com/posts/7EEBVC.html</id>
    <published>2024-12-31T14:45:02.461Z</published>
    <updated>2024-12-31T14:45:02.461Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>当拖拽文件夹上传时，实际上将文件夹当作文件上传的。换言之，并没有拿到实际的文件列表，包括在多选的时候，选上了文件夹。如果抛弃使用 <code>element-ui</code> 的 <code>uploader</code>，使用 <code>input</code> ,在拖拽的时候，若是没有权限允许，以久没办法拿到文件信息。</p><p><a href="Extras/Media/4c67138c7fc7af237846734bbe2e308b_MD5.png">Open file:</a><br /><img                       lazyload                     src="/images/loading.svg"                     data-src="Extras/Media/4c67138c7fc7af237846734bbe2e308b_MD5.png"                      alt=""                 ></p><h2 id="解决思路"><a class="markdownIt-Anchor" href="#解决思路"></a> 解决思路</h2><ol><li>在 <code>drop</code> 事件中获取 <code>e.dataTransfer. Items</code> ，是一个 <code>DataTransferItemList</code> 对象，遍历得到 <code>DataTransferItem</code> 对象</li><li>用 <code>webkitGetAsEntry</code> 方法得到 <code>FileSystemEntry</code> 对象</li><li>根据 <code>isFile</code> 属性判断 entry 是文件还是文件夹。是文件的话，用 <code>file</code> 方法获取 <code>File</code> 对象；是文件夹的话，递归地用 <code>reader</code> 读取包含的文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  </span><br><span class="line">  &lt;el-container&gt;  </span><br><span class="line">    &lt;el-upload  </span><br><span class="line">        class=&quot;upload-demo&quot;  </span><br><span class="line">        :auto-upload=&quot;false&quot;  </span><br><span class="line">        drag  </span><br><span class="line">        action=&quot;#&quot;  </span><br><span class="line">        multiple  </span><br><span class="line">        :file-list.sync=&quot;fileList&quot;  </span><br><span class="line">        :before-upload=&quot;handleChange&quot;  </span><br><span class="line">        :on-change=&quot;handleChange&quot;  </span><br><span class="line">        :show-file-list=&quot;false&quot;  </span><br><span class="line">    &gt;  </span><br><span class="line">      &lt;i class=&quot;el-icon-upload&quot;&gt;&lt;/i&gt;  </span><br><span class="line">      &lt;div class=&quot;el-upload__text&quot;&gt;将文件拖到此处，或&lt;em&gt;点击上传&lt;/em&gt;&lt;/div&gt;  </span><br><span class="line">      &lt;div class=&quot;el-upload__tip&quot; slot=&quot;tip&quot;&gt;  </span><br><span class="line">        只能上传jpg/png文件，且不超过500kb  </span><br><span class="line">      &lt;/div&gt;  </span><br><span class="line">    &lt;/el-upload&gt;  </span><br><span class="line">  &lt;/el-container&gt;  </span><br><span class="line">&lt;/template&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;script&gt;  </span><br><span class="line">export default &#123;  </span><br><span class="line">  name: &#x27;App&#x27;,  </span><br><span class="line">  components: &#123;&#125;,  </span><br><span class="line">  directives: &#123;  </span><br><span class="line">    webkitdirectory: &#123;  </span><br><span class="line">      inserted(el) &#123;  </span><br><span class="line">        // 递归获取  </span><br><span class="line">        function getFileFromEntryRecur(entry, cb) &#123;  </span><br><span class="line">          if (entry.isFile) &#123;  </span><br><span class="line">            entry.file(file =&gt; &#123;  </span><br><span class="line">              let path = entry.fullPath.substring(1);  </span><br><span class="line">              cb(&#123;file, path&#125;);  </span><br><span class="line">            &#125;);  </span><br><span class="line">          &#125; else &#123;  </span><br><span class="line">            let reader = entry.createReader();  </span><br><span class="line">            reader.readEntries(entries =&gt; &#123;  </span><br><span class="line">              entries.forEach(entry =&gt; &#123;  </span><br><span class="line">                getFileFromEntryRecur(entry,cb);  </span><br><span class="line">              &#125;);  </span><br><span class="line">            &#125;,e=&gt;&#123;  </span><br><span class="line">              console.log(`e--&gt;`, e);  </span><br><span class="line">            &#125;);  </span><br><span class="line">          &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        // Hack 部分  </span><br><span class="line">        el.querySelector(&#x27;.el-upload-dragger&#x27;).addEventListener(&#x27;drop&#x27;, (data) =&gt; &#123;  </span><br><span class="line">          for (let each of data.dataTransfer.items) &#123;  </span><br><span class="line">            const entry = each.webkitGetAsEntry();  </span><br><span class="line">            getFileFromEntryRecur(entry, (file) =&gt; &#123;  </span><br><span class="line">              console.log(`file--&gt;`, file);  </span><br><span class="line">            &#125;);  </span><br><span class="line">          &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">      &#125;,  </span><br><span class="line">    &#125;,  </span><br><span class="line">  &#125;,  </span><br><span class="line">  data() &#123;  </span><br><span class="line">    return &#123;  </span><br><span class="line">      fileList: [],  </span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  methods: &#123;  </span><br><span class="line">    handleChange(file) &#123;  </span><br><span class="line">      console.log(file);  </span><br><span class="line">    &#125;,  </span><br><span class="line">  &#125;,  </span><br><span class="line">&#125;;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>同样的对于 <code>input</code>，也可以基于此方法进行修改。</p><p>但是，文件的相对路径格式不统一，需要处理，统一格式为<code>文件夹 1/文件夹 2/a.txt </code>。</p><p>途径相对路径说明</p><p><a href="Extras/Media/e16b57707f97dd9fd77b1db44d89be2a_MD5.png">Open file:</a><br /><img                       lazyload                     src="/images/loading.svg"                     data-src="Extras/Media/e16b57707f97dd9fd77b1db44d89be2a_MD5.png"                      alt=""                 ></p><h2 id="api-兼容情况"><a class="markdownIt-Anchor" href="#api-兼容情况"></a> API 兼容情况</h2><p><a href="Extras/Media/86c6b77fe3af9faf18de1493fd00a3c7_MD5.png">Open file:</a><br /><img                       lazyload                     src="/images/loading.svg"                     data-src="Extras/Media/86c6b77fe3af9faf18de1493fd00a3c7_MD5.png"                      alt=""                 ></p><h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2><blockquote><p>!注意<br /><code>webkitGetAsEntry</code> 这个函数在读取某个文件夹的文件数大于100个时只会读取前100个</p></blockquote><h2 id="参考信息"><a class="markdownIt-Anchor" href="#参考信息"></a> 参考信息</h2><blockquote><p>参考链接<br /><a class="link"   href="https://blog.csdn.net/tangran0526/article/details/104156857#:~:text=%E4%B8%8A%E4%BC%A0%E4%B8%89%E5%90%88%E4%B8%80%EF%BC%9A%E6%8B%96%E6%8B%BD%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E3%80%81%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E4%B8%80%E6%AC%A1%E6%90%9E%E5%AE%9A%EF%BC%81%201%201%20%E6%8B%96%E6%8B%BD%E4%B8%8A%E4%BC%A0%20%E5%9C%A8%20drop%20%E4%BA%8B%E4%BB%B6%E4%B8%AD%E9%80%9A%E8%BF%87%20e.dataTransfer.items,%E4%B8%89%E5%90%88%E4%B8%80%20%E8%BF%99%E4%B8%89%E7%A7%8D%E4%B8%8A%E4%BC%A0%E9%80%94%E5%BE%84%EF%BC%8C%E6%9C%80%E7%BB%88%E9%83%BD%E6%8B%BF%E5%88%B0%20File%20%E5%AF%B9%E8%B1%A1%EF%BC%9A%20%E4%BD%86%E6%98%AF%EF%BC%8C%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E6%A0%BC%E5%BC%8F%E4%B8%8D%E7%BB%9F%E4%B8%80%EF%BC%8C%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%EF%BC%8C%E7%BB%9F%E4%B8%80%E6%A0%BC%E5%BC%8F%E4%B8%BA%20%E6%96%87%E4%BB%B6%E5%A4%B91%2F%E6%96%87%E4%BB%B6%E5%A4%B92%2Fa.txt%20%E3%80%82%20" >上传三合一：拖拽上传、上传文件、上传文件夹，一次搞定！_呀呀夫斯基的博客-CSDN博客<i class="fas fa-external-link-alt"></i></a><br /><a class="link"   href="https://github.com/fex-team/webuploader" >GitHub - fex-team/webuploader: It’s a new file uploader solution!<i class="fas fa-external-link-alt"></i></a><br /><a class="link"   href="https://blog.csdn.net/tangran0526/article/details/104108551" >拖拽本地文件夹到浏览器中，展示所有文件结构_webkitgetasentry_呀呀夫斯基的博客-CSDN博客<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;问题描述&quot;</summary>
      
    
    
    
    <category term="公司经历以及问题记录" scheme="http://example.com/categories/%E5%85%AC%E5%8F%B8%E7%BB%8F%E5%8E%86%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="项目中问题记录" scheme="http://example.com/categories/%E5%85%AC%E5%8F%B8%E7%BB%8F%E5%8E%86%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="开发Bug" scheme="http://example.com/categories/%E5%85%AC%E5%8F%B8%E7%BB%8F%E5%8E%86%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%BC%80%E5%8F%91Bug/"/>
    
    
  </entry>
  
  <entry>
    <title>EXCEL 预览方案及其实现</title>
    <link href="http://example.com/posts/32JE53R.html"/>
    <id>http://example.com/posts/32JE53R.html</id>
    <published>2024-12-31T14:45:02.460Z</published>
    <updated>2024-12-31T14:45:02.461Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="面临的问题"><a class="markdownIt-Anchor" href="#面临的问题"></a> 面临的问题</h2><p>实现在线表格数据预览，目前比较通用的表格格式为 <code>xlsx</code> 、<code>xls</code> 、<code>csv</code> 等，在本次项目中，需要预览以及编辑单元格数据。</p><h2 id="解决方案汇总"><a class="markdownIt-Anchor" href="#解决方案汇总"></a> 解决方案汇总</h2><h3 id="luckysheet"><a class="markdownIt-Anchor" href="#luckysheet"></a> Luckysheet</h3><blockquote><p>相关链接<br /><a class="link"   href="https://mengshukeji.gitee.io/luckysheetdocs/zh/" >Luckysheet文档<i class="fas fa-external-link-alt"></i></a><br /><a class="link"   href="https://juejin.cn/post/7102255426363719716" >luckysheet(1): 在线 excel 介绍及使用 - 掘金<i class="fas fa-external-link-alt"></i></a><br /><a class="link"   href="https://juejin.cn/post/7104175160315346957" >luckysheet(2) : 前后端存储展示实战 - 掘金<i class="fas fa-external-link-alt"></i></a><br /><a class="link"   href="https://juejin.cn/post/7148683131418050590" >luckysheet(3):基于 luckysheet 实现自定义报表 - 掘金<i class="fas fa-external-link-alt"></i></a></p></blockquote><h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3><p>需要在 <code>Vue</code> 中引入 <code>jQuery</code> 。</p><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ul><li>包含大量常用电子表格功能。</li><li>最少的配置就能开始上手使用</li><li>社区驱动</li></ul><h2 id="x-spreadsheet"><a class="markdownIt-Anchor" href="#x-spreadsheet"></a> X-spreadsheet</h2><blockquote><p>相关链接<br /><a class="link"   href="https://github.com/myliang/x-spreadsheet" >GitHub - myliang/x-spreadsheet: The project has been migrated to @wolf-table/table https://github.com/wolf-table/table<i class="fas fa-external-link-alt"></i></a><br /><a class="link"   href="https://hondrytravis.com/x-spreadsheet-doc/" >X-Spreadsheet中文文档<i class="fas fa-external-link-alt"></i></a><br /><a class="link"   href="https://juejin.cn/post/7086261579083153445" >在Vue中使用x-data-spreadsheet - 掘金<i class="fas fa-external-link-alt"></i></a><br /><a class="link"   href="https://juejin.cn/post/6998707107138633758" >x-spreadsheet学习 - 掘金<i class="fas fa-external-link-alt"></i></a><br /><a class="link"   href="https://starlightunion.github.io/blog/frontend/vue/x-data-spreadsheet-practice.html" >web表格x-data-spreadsheet实践 | 个人技术的分享<i class="fas fa-external-link-alt"></i></a></p></blockquote><h3 id="问题-2"><a class="markdownIt-Anchor" href="#问题-2"></a> 问题</h3><p>需要引入 <code>less</code> ,不过作为预编的话，可以不影响其他东西。</p><h3 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2"></a> 优点</h3><p>事件监听系统比较丰富，基于 <code>Canvas</code> 实现。</p><h3 id="具体实验步骤"><a class="markdownIt-Anchor" href="#具体实验步骤"></a> 具体实验步骤</h3><h3 id="目标"><a class="markdownIt-Anchor" href="#目标"></a> 目标</h3><ul><li>[ ] 支持导入 xlsx 、 xlx 、 csv 文件</li><li>[ ] 支持导出 xlsx 文件</li><li>[ ] 支持上传修改后的表格文件</li><li>[ ] 支持从服务端下载表格文件</li></ul><h3 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h3><p><a class="link"   href="https://blog.csdn.net/qq_42120178/article/details/111636027" >x-data-spreadsheet 在线编辑excel文件，支持导入/导出/上传/读取网络 excel，合并单元格（vue版本）_Dreamy_Lois的博客-CSDN博客<i class="fas fa-external-link-alt"></i></a></p><h3 id="前端"><a class="markdownIt-Anchor" href="#前端"></a> 前端</h3><p>百分白按照参照对象实现。</p><blockquote><p>[!WARRING] 额外必备环境💡</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;dependencied&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;x-data-spreadsheet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.1.8&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;xlsx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.15.1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;less&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.1.3&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;less-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^11.1.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="Extras/Media/2146737de8948dfff78d5c73662c64ac_MD5.png"                      alt="文件信息"                 ></p><h3 id="后端"><a class="markdownIt-Anchor" href="#后端"></a> 后端</h3><blockquote><p>只对后端接收文件部分进行了测试，上传文件和本地上传文件道理一样，不额外测试</p></blockquote><p><a href="Extras/Media/34e9898f4d4a85cba2e68953db4b7401_MD5.png">Open file:</a><br /><img                       lazyload                     src="/images/loading.svg"                     data-src="Extras/Media/34e9898f4d4a85cba2e68953db4b7401_MD5.png"                      alt=""                 ></p><blockquote><p>均为 <code>MIT</code> 开源协议</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;面临的问题</summary>
      
    
    
    
    <category term="公司经历以及问题记录" scheme="http://example.com/categories/%E5%85%AC%E5%8F%B8%E7%BB%8F%E5%8E%86%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="项目中问题记录" scheme="http://example.com/categories/%E5%85%AC%E5%8F%B8%E7%BB%8F%E5%8E%86%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="开发Bug" scheme="http://example.com/categories/%E5%85%AC%E5%8F%B8%E7%BB%8F%E5%8E%86%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%BC%80%E5%8F%91Bug/"/>
    
    
    <category term="实现方案" scheme="http://example.com/tags/%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    
    <category term="前端开发" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频保存方案</title>
    <link href="http://example.com/posts/20VS9Q4.html"/>
    <id>http://example.com/posts/20VS9Q4.html</id>
    <published>2024-12-31T14:45:02.459Z</published>
    <updated>2024-12-31T14:45:02.460Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>相关 API： MediaRecorder、Blob<br />原理：追踪视频流的 track,逐段保留 blob,然后组合为 File 对象，提交到后端。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">EnsuredInitialed</span> &#123;</span><br><span class="line">    <span class="attr">_cached</span>: <span class="title class_">Function</span>[] = [];</span><br><span class="line">    is_loaded = <span class="literal">false</span>;</span><br><span class="line">    <span class="attr">_messages</span>: <span class="built_in">any</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">then</span>(<span class="params">fn: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">is_loaded</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_cached</span>.<span class="title function_">push</span>(fn);</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">_messages</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">loaded</span>(<span class="params">messages: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">is_loaded</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_messages</span> = messages;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_cached</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">fn</span>(messages);</span><br><span class="line">            &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">destroy</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_cached</span>.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">is_loaded</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">EnsuredInitialed</span>&#125; <span class="keyword">from</span> <span class="string">&quot;./utils&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">StreamingRecorderLoader</span> <span class="keyword">extends</span> <span class="title class_ inherited__">EnsuredInitialed</span> &#123;</span><br><span class="line">    <span class="attr">_recorder</span>: <span class="title class_">MediaRecorder</span> | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="attr">_options</span>: <span class="title class_">MediaRecorderOptions</span> = &#123;</span><br><span class="line">        <span class="attr">mimeType</span>: <span class="string">&quot;video/webm;codecs=vp9&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">/*@ts-ignore*/</span></span><br><span class="line">    <span class="attr">_stream</span>: <span class="title class_">MediaStream</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="attr">_blobs</span>: <span class="title class_">Blob</span>[] = [];</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options: Partial&lt;MediaRecorderOptions&gt;</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">this</span>.#<span class="title function_">init</span>();</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>.<span class="property">_options</span>, options)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">loaded</span>(<span class="params">stream: MediaStream</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_recorder</span> = <span class="keyword">new</span> <span class="title class_">MediaRecorder</span>(stream, <span class="variable language_">this</span>.<span class="property">_options</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_stream</span> = stream;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">loaded</span>(<span class="variable language_">this</span>.<span class="property">_recorder</span> <span class="keyword">as</span> <span class="title class_">MediaRecorder</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_blobs</span> = [];</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_recorder</span>?.<span class="title function_">start</span>();</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">_recorder</span>!.<span class="property">onstop</span> = resolve;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">_recorder</span>?.<span class="title function_">stop</span>();</span><br><span class="line">            &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="title function_">getBlob</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Blob</span>(<span class="variable language_">this</span>.<span class="property">_blobs</span>, &#123;<span class="attr">type</span>: <span class="variable language_">this</span>.<span class="property">_options</span>.<span class="property">mimeType</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">geFileObj</span>(<span class="params">filename: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">File</span>([<span class="variable language_">this</span>.<span class="title function_">getBlob</span>()], filename, &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="variable language_">this</span>.<span class="property">_options</span>.<span class="property">mimeType</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="title function_">save</span>(<span class="params">filename: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">is_loaded</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_recorder</span>!.<span class="property">onstop</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> blob = <span class="variable language_">this</span>.<span class="title function_">getBlob</span>();</span><br><span class="line">            <span class="comment">// 创建下载链接</span></span><br><span class="line">            <span class="keyword">const</span> url = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line">            <span class="keyword">const</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            a.<span class="property">href</span> = url;</span><br><span class="line">            a.<span class="property">download</span> = filename || <span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span>;</span><br><span class="line">            a.<span class="title function_">click</span>();</span><br><span class="line">            <span class="variable constant_">URL</span>.<span class="title function_">revokeObjectURL</span>(a.<span class="property">href</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">ondataavailable</span>(<span class="params">e: MediaRecorderEventMap[<span class="string">&#x27;dataavailable&#x27;</span>]</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_blobs</span>.<span class="title function_">push</span>(e.<span class="property">data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    #<span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_recorder</span>?.<span class="title function_">addEventListener</span>(<span class="string">&quot;dataavailable&quot;</span>, <span class="variable language_">this</span>.<span class="property">ondataavailable</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>))</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> streamingRecorder = <span class="keyword">new</span> <span class="title class_">StreamingRecorderLoader</span>(&#123;</span><br><span class="line">    <span class="attr">mimeType</span>: <span class="string">&quot;video/webm;codecs=vp9&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析"></a> 代码分析</h2><ol><li><p>先说工具类<code>EnsuredInitialed</code>,这是一个确保，loaded 执行之后，then 中的才开始能够执行的工具类，这是对异步操作的一个解构方法，从而确保 stream 都能够正常执行，基本原理是判断是否加载完，加载完之后把信息存下来，在 then 的时候判断是否已经加载完了，如果没有加载完，就放入 cached 中，反之，直接执行，并获得这个消息。</p></li><li><p>再说核心截取部分，确保 loaded 中有需要 track 的 MediaStream，这个 stream 可以用于 video.srcObject 获取,MediaRecorder 提供了 start,stop, 来录制的控制开始与结束，以及 pause,resume 来暂停与恢复，有几个比较关键的事件：</p></li></ol><ul><li><p>ondataavailable<br />调用它用来处理 dataavailable 事件，该事件可用于获取录制的媒体资源 (在事件的 data 属性中会提供一个可用的 Blob 对象.)</p></li><li><p>onstart<br />用来处理 start 事件，该事件在媒体开始录制时触发（MediaRecorder.start() (en-US)）.</p></li><li><p>onstop<br />用来处理 stop 事件，该事件会在媒体录制结束时、媒体流（MediaStream）结束时、或者调用 MediaRecorder.stop() (en-US) 方法后触发。stop 的时候停止录制。同时触发 dataavailable 事件，返回一个存储 Blob 内容的录制数据。因此需要手动触发一次 stop,否则录取的信息是无效的。</p></li></ul><h2 id="mediastreamtrack"><a class="markdownIt-Anchor" href="#mediastreamtrack"></a> MediaStreamTrack</h2><p>如何理解 track ,首先要弄清楚一个概念——音轨，准确来说是轨道，音视频是以二进制存在的，输出需要在一个轨道上，有点留声机那种感觉，针放在哪个轨道放哪一个，合在一起那就混音了，因此每一个轨道也可能有多个通道，每一个通道代表了一个媒体流的最小单元，比如声音放大啊（，在这某一线段）。</p><p>在 Chromium 源码中(media_track.h,media\base\media_tracks.h)，定义了 MediaTrack，方法中通过 TrackTypeToStr 反映当前是视频还是音频，而后者创建了一个 MediaTracksCollection。对其进行了拼接粘合操作。</p><p>// A few notes on sample rates of common formats:<br />// - AAC files are limited to 96 kHz.<br />// - MP3 files are limited to 48 kHz.<br />// - Vorbis used to be limited to 96 kHz, but no longer has that<br />// restriction.<br />// - Most PC audio hardware is limited to 192 kHz, some specialized DAC<br />// devices will use 768 kHz though.</p><h2 id="展望与拓展"><a class="markdownIt-Anchor" href="#展望与拓展"></a> 展望与拓展</h2><ul><li><p>能录制，也能做到边录边播（参考 MediaSource)，也就是能截取到每一帧的信息，进行加工处理，那么就可以做很多有趣的东西了。</p></li><li><p>一下是对于 ArrayBuffer Blob File 之间的关系操作总结<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_89e6a0e4aab3f690eacef916b31901db_r.png"                      alt=""                 ></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="项目中问题记录" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="一些有的没的技术" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>UE 与前端交互接口封装</title>
    <link href="http://example.com/posts/2TKNP0E.html"/>
    <id>http://example.com/posts/2TKNP0E.html</id>
    <published>2024-12-31T14:45:02.458Z</published>
    <updated>2024-12-31T14:45:02.458Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="预置"><a class="markdownIt-Anchor" href="#预置"></a> 预置</h2><h3 id="基本介绍"><a class="markdownIt-Anchor" href="#基本介绍"></a> 基本介绍</h3><p>利用<strong>像素流送</strong>可以在用户不可见的电脑上远程运行虚幻引擎应用程序。举例而言，这台电脑可以是机构中的一台实体电脑，也可以是云端服务提供的虚拟机。虚幻引擎将使用该电脑可用的资源（CPU、GPU、内存等）来运行游戏逻辑并渲染每一帧。它会不断将此渲染输出编码到一个媒体流送中，再通过一个轻量级的网页服务堆栈进行传递。用户即可在其他电脑和移动设备上运行的标准网页浏览器中查看直播流送。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_59a4dd3f56ffaf639361e39edd3f3fb1_r.png"                      alt=""                 ></p><blockquote><p>本文将重点阐述<strong>前端</strong>与<strong>UE</strong>的交互过程。</p></blockquote><h3 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h3><p>在像素流送过程中，不仅需要考虑 UE 如和展示在界面上，往往还需要<strong>前端</strong>与<strong>UE</strong>交互，但是官方提供的接口，有一种类似<a class="link"   href="https://www.cloudflare.com/zh-cn/learning/ddos/glossary/user-datagram-protocol-udp/" >UDP<i class="fas fa-external-link-alt"></i></a>，那种让人不安全的感觉，如果只是单发送，单接收还好，但涉及到逐步交互，就需要将逻辑拆开来处理，比如打开 <strong>UE</strong> 场景中的一些模型，操作这个模型，结束操作，获得这个信息，用户的注意力会从前端转到<strong>UE</strong>，再从<strong>UE</strong>转到<strong>前端</strong>，而我们更加习惯使用<strong>异步</strong>或者<strong>回调</strong>的方式去理解接口。因此便有了本次封装。</p><h3 id="相关接口预置知识"><a class="markdownIt-Anchor" href="#相关接口预置知识"></a> 相关接口预置知识</h3><p>像素流送，分为三个端去理解（准确来说，WebRTC 这种模式都需要三个端去理解）</p><ul><li>Browser 浏览器</li><li>Signal 信令服务器（不过多描述）</li><li>UE Application UE 应用（不过多描述）</li></ul><h4 id="浏览器与-ue-应用-通信"><a class="markdownIt-Anchor" href="#浏览器与-ue-应用-通信"></a> 浏览器与 UE 应用 通信</h4><p>在浏览器中，会引入对应的库，目前是直接挂在 Windows 对象下，可以直接调用</p><ul><li>发送消息：<code>window.emitUIInteraction</code>函数向 UE 应用 发送消息，</li><li>接收消息：使用 <code>window.addResponseEventListener</code> ,监听 UE 应用发送过来的消息，完成分步交互。</li></ul><h2 id="接口封装"><a class="markdownIt-Anchor" href="#接口封装"></a> 接口封装</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> - <span class="doctag">@typeParam</span> <span class="variable">T</span> - 接收到的数据体</span></span><br><span class="line"><span class="comment"> - */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">IUECommandStruct</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="attr">commandType</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">commandData</span>: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> event_map = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="title class_">Set</span>&lt;<span class="title class_">Function</span>&gt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> - <span class="doctag">@desc</span> 发送到 UE</span></span><br><span class="line"><span class="comment"> - <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; commandType 接口类型</span></span><br><span class="line"><span class="comment"> - <span class="doctag">@param</span> commandData 传入数据</span></span><br><span class="line"><span class="comment"> - <span class="doctag">@param</span> <span class="variable">receiveCommandType</span></span></span><br><span class="line"><span class="comment"> - <span class="doctag">@example</span></span></span><br><span class="line"><span class="comment"> - // 打开绘制编辑器</span></span><br><span class="line"><span class="comment"> - sendToUe(&quot;Test-Draw-Line&quot;,&quot;ID&quot;,&quot;Line&quot;).then(()=&gt;&#123;</span></span><br><span class="line"><span class="comment"> - &#125;&#125;);</span></span><br><span class="line"><span class="comment"> - # Cancel</span></span><br><span class="line"><span class="comment"> - const helper = sendToUe();</span></span><br><span class="line"><span class="comment"> - helper.cancel();</span></span><br><span class="line"><span class="comment"> - */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sendToUe = (<span class="attr">commandType</span>: <span class="built_in">string</span>, <span class="attr">commandData</span>: <span class="built_in">any</span>, receiveCommandType?: <span class="built_in">string</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">IUECommandStruct</span>&lt;<span class="built_in">any</span>&gt;&gt; =&gt; &#123;</span><br><span class="line">    <span class="comment">//    记录当前消息的发送情况</span></span><br><span class="line">    <span class="keyword">let</span> reject;</span><br><span class="line">    <span class="keyword">const</span> promisify = <span class="keyword">new</span> <span class="title class_">Promise</span>&lt;<span class="title class_">IUECommandStruct</span>&lt;<span class="built_in">any</span>&gt;&gt;(<span class="function">(<span class="params">resolve, _reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">emitUIInteraction</span>(&#123;</span><br><span class="line">            commandType,</span><br><span class="line">            commandData,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 如果是单项发送</span></span><br><span class="line">        <span class="keyword">if</span> (!receiveCommandType) <span class="keyword">return</span> <span class="title function_">resolve</span>(&#123;</span><br><span class="line">            commandType,</span><br><span class="line">            <span class="attr">commandData</span>: <span class="string">&#x27;Success&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 取消监听</span></span><br><span class="line">        <span class="keyword">const</span> unlisten = <span class="title function_">listenUe</span>(receiveCommandType, <span class="function">(<span class="params">data, destroy</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(data <span class="keyword">as</span> <span class="title class_">IUECommandStruct</span>&lt;<span class="built_in">any</span>&gt;);</span><br><span class="line">            <span class="comment">// 对于这种一次性数据，使用完之后就移除掉</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="title function_">destroy</span>();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 退出监听</span></span><br><span class="line">        reject = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">_reject</span>();</span><br><span class="line">            <span class="title function_">unlisten</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 执行后将移除本次监听</span></span><br><span class="line">    <span class="comment">// 是否取消本次监听</span></span><br><span class="line">    <span class="comment">/*@ts-ignore*/</span></span><br><span class="line">    promisify.<span class="property">cancel</span> = reject;</span><br><span class="line">    <span class="keyword">return</span> promisify;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> - <span class="doctag">@desc</span> 通过监听一个命令，获取数据</span></span><br><span class="line"><span class="comment"> - <span class="doctag">@param</span> command 需要监听的命令</span></span><br><span class="line"><span class="comment"> - <span class="doctag">@param</span> fn 回调,返回对应监听的列信息</span></span><br><span class="line"><span class="comment"> - */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">listenUe</span>(<span class="params">command: <span class="built_in">string</span>, fn: (data: <span class="built_in">any</span>, destroy: <span class="built_in">Function</span>) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params">data: <span class="built_in">any</span>, destroy: <span class="built_in">Function</span></span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">fn</span>(data, destroy);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 监听事件信息</span></span><br><span class="line">    <span class="title function_">listen</span>(command, callback);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 移除对应函数</span></span><br><span class="line">        <span class="comment">// 事件一旦发生，这个就是不可保留的，可以进行回退，如果一次性取消全部的事件信息</span></span><br><span class="line">        <span class="comment">// 会导致其他对应能存储的事件无用了</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            event_map.<span class="title function_">get</span>(command)?.<span class="title function_">delete</span>(callback);</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(command, <span class="string">&quot;it has destroyed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 只供本文件使用</span></span><br><span class="line"><span class="comment">- */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">listen</span>(<span class="params">command: <span class="built_in">string</span>, callback: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fns = event_map.<span class="title function_">get</span>(command);</span><br><span class="line">    <span class="keyword">if</span> (!fns) event_map.<span class="title function_">set</span>(command, <span class="keyword">new</span> <span class="title class_">Set</span>&lt;<span class="title class_">Function</span>&gt;());</span><br><span class="line">    <span class="keyword">return</span> event_map.<span class="title function_">get</span>(command)!.<span class="title function_">add</span>(callback);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分发任务</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">emit</span>(<span class="params">command: <span class="built_in">string</span>, data: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fns = event_map.<span class="title function_">get</span>(command);</span><br><span class="line">    fns?.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">callback</span>(data, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 异步的销毁本函数</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fns.<span class="title function_">delete</span>(callback);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> - 异步去监听事件打开，并在收到 Line 事件的时候返回</span></span><br><span class="line"><span class="comment"> - */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">sendAndWaitResponse</span> = (<span class="params">ID: <span class="built_in">string</span></span>) =&gt; <span class="title function_">sendToUe</span>(<span class="string">&#x27;Test&#x27;</span>, <span class="variable constant_">ID</span>, <span class="string">&#x27;Line&#x27;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> - 仅仅发送事件,请求打开地图画点，不关心是否收到数据</span></span><br><span class="line"><span class="comment"> - */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">send</span> = (<span class="params">ID: <span class="built_in">string</span></span>) =&gt; <span class="title function_">sendToUe</span>(<span class="string">&quot;Test&quot;</span>, <span class="variable constant_">ID</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> - 仅仅监听事件，不需要任何发送</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> - */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">listen</span> = (<span class="params">fn: <span class="built_in">Function</span></span>) =&gt; <span class="title function_">listenUe</span>(<span class="string">&quot;Line&quot;</span>, fn);</span><br></pre></td></tr></table></figure><h3 id="关键函数讲解"><a class="markdownIt-Anchor" href="#关键函数讲解"></a> 关键函数讲解</h3><ul><li><code>SendToUe</code></li></ul><p>函数会返回一个 <code>Promise</code> 对象，并额外增加了 <code>cancel</code> 函数，争对返回的结果进行取消等待，正如<code>sendAndWaitResponse</code> 注释所描述，这里会等待第三个参数，也就是 <code>Line</code> 这个对应的事件接收到的时候，才会进行 <code>resolve</code>，如果没有第三个参数，为了保证统一，也返回了一个<code>Promise</code>对象。</p><ul><li><code>listenUe</code><br />函数会返回一个用于主动 unlisten 的函数，用于该任务还没发起，但是组件即将卸载，也就是这个函数没用了，所以需要提前释放掉，传入参数为需要监听的命令类型和一个函数，用户执行完相关数据，需要手动 <code>destroy</code> 这个函数，类似与 <code>unlisten</code> ,一般在达到某个条件的时候，不需要监听了，而这个组件仍然还需要使用的时候，手动注销。这是为了避免函数反复注册，从出现<strong>内存泄露</strong>。</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>本文简要介绍了像素流送、前端到 UE 的交互方式及其二次封装的方法。解决了分步调用<strong>UE</strong>的异步逻辑问题，实现了类 axios 的交互方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;预置&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="项目中问题记录" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="一些有的没的技术" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Monorepo介绍</title>
    <link href="http://example.com/posts/38XT3TW.html"/>
    <id>http://example.com/posts/38XT3TW.html</id>
    <published>2024-12-31T14:45:02.455Z</published>
    <updated>2024-12-31T14:45:02.455Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="monorepo-介绍"><a class="markdownIt-Anchor" href="#monorepo-介绍"></a> Monorepo 介绍</h2><h3 id="技术缘由"><a class="markdownIt-Anchor" href="#技术缘由"></a> 技术缘由</h3><h4 id="是什么"><a class="markdownIt-Anchor" href="#是什么"></a> 是什么？</h4><p>所谓 <code>Monorepo</code> 就是将多个项目放置在一个项目中，并借助管理工具对项目之间的 <code>版本进度</code>，<code>部署状况</code>，<code>依赖信息</code>。可以达到规范团队风格，沉淀可复用的组件库，建立工具库的能力。现如今有许多公司，团队开始采用这种方案。如 <code>vue</code>, <code>unocss</code>。经典的安装方式 <code>@vue/…</code>， <code>@unocss/…a</code> 。</p><h4 id="为什么"><a class="markdownIt-Anchor" href="#为什么"></a> 为什么？</h4><h5 id="1-苗条的项目包"><a class="markdownIt-Anchor" href="#1-苗条的项目包"></a> 1. 苗条的项目包</h5><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">|---project A       // for A Project</span><br><span class="line">|---node_modules </span><br><span class="line">|--- vue</span><br><span class="line">|--- lodash.toString</span><br><span class="line">|---packages.json</span><br><span class="line">|---project B        // for B Project</span><br><span class="line">|---node_modules </span><br><span class="line">|--- vue</span><br><span class="line">|--- lodash.Object</span><br><span class="line">|---packages.json</span><br><span class="line">|---porject C       // for C Project</span><br><span class="line">|---node_modules </span><br><span class="line">|--- vue</span><br><span class="line">|--- lodash.Number</span><br><span class="line">|---packages.json</span><br></pre></td></tr></table></figure><p>正如上图所示，我们在开发的时候，毫无疑问有许多不同的工程项目，<code>node_modules</code> 黑洞也就随之而来，比如 <code>vue</code> ，在项目中已经出现了不止一次。那么这个其实是不需要在 <code>Project B</code> 中又安装一次的。可以转而软链复用。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">|---node_modules     // 通用的包</span><br><span class="line">|--vue</span><br><span class="line">|---project A       // for A Project</span><br><span class="line">|---node_modules </span><br><span class="line">|--lodash.toString</span><br><span class="line">|---packages.json</span><br><span class="line">|---project B        // for B Project</span><br><span class="line">|---node_modules </span><br><span class="line">|--lodash.Object</span><br><span class="line">|---packages.json</span><br><span class="line">|---porject C       // for C Project</span><br><span class="line">|---node_modules </span><br><span class="line">|--lodash.Number</span><br><span class="line">|---packages.json</span><br><span class="line">|---packages.json    // 管理全局的通用包</span><br><span class="line">|---*-workspace.yaml // 指定哪些文件是属于工作区的</span><br></pre></td></tr></table></figure><p>这样就使得项目变得更加干净。</p><p>在项目开发中，我们经常会有 <code>.eslintrc</code>，<code>.prettierc</code>， <code>.editorconfig</code>，<code>.stylelint</code>，以及一堆 <code>jsconfig.js</code>，<code>tsconfig.js</code>，之类的一堆规范化的工具。那么这些也可以借助上面实现通用。</p><h5 id="2-自动化的文档管理"><a class="markdownIt-Anchor" href="#2-自动化的文档管理"></a> 2. 自动化的文档管理</h5><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">|---project A       // for A Project</span><br><span class="line">|---node_modules </span><br><span class="line">|--vue</span><br><span class="line">|--lodash.toString</span><br><span class="line">|---packages.json</span><br><span class="line">|---READMD.md</span><br><span class="line">|---project B        // for B Project</span><br><span class="line">|---node_modules </span><br><span class="line">|--vue</span><br><span class="line">|--lodash.Object</span><br><span class="line">|---packages.json</span><br><span class="line">|---READMD.md</span><br><span class="line">|---porject C       // for C Project</span><br><span class="line">|---node_modules </span><br><span class="line">|--vue</span><br><span class="line">|--lodash.Number</span><br><span class="line">|---packages.json</span><br><span class="line">|---READMD.md</span><br></pre></td></tr></table></figure><p>在每个项目开发完成之后, 也有一些 <code>README.md</code> 作为项目介绍，或者使用说明的文档。 在 <code>Monorepo</code> 中可以通过脚手架工具，将文档进行收集，管理。</p><h5 id="3-简易的实验场"><a class="markdownIt-Anchor" href="#3-简易的实验场"></a> 3. 简易的实验场</h5><p>这种管理方式可大可小，可以作为自己写的一些小 <code>kit</code>，但是往往会发现自己写的东西有需要 copy，然后修改，然后发现一堆重复，不妨试一下 <code>workspace</code>，一句话管理。<br />以 <code>pnpm-workspace</code> 为例：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">|---node_modules     // 通用的包</span><br><span class="line">|--vue</span><br><span class="line">|---project A       // for A Project</span><br><span class="line">|---node_modules  </span><br><span class="line">|--lodash.toString</span><br><span class="line">|---packages.json // name: @workspace/pa</span><br><span class="line">|---project B        // for B Project</span><br><span class="line">|---node_modules </span><br><span class="line">|--lodash.Object</span><br><span class="line">|---packages.json // name: @workspace/pb</span><br><span class="line">|---porject C       // for C Project</span><br><span class="line">|---node_modules </span><br><span class="line">|--lodash.Number</span><br><span class="line">|---packages.json // name: @workspace/pc</span><br><span class="line">|---packages.json    // 管理全局的通用包</span><br><span class="line">|---*-workspace.yaml // 指定哪些文件是属于工作区的</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm --filter @workspace/pc add @workspace/pa </span><br></pre></td></tr></table></figure><p>然后就当作依赖直接使用了. 进一步可以自己写一个 <code>cli</code> 工具， 实现自动化构建，部署等。</p><h5 id="4-微模块化"><a class="markdownIt-Anchor" href="#4-微模块化"></a> 4. 微模块化</h5><p>这一部分思想 [Elux 基本概念 | Elux]( <a class="link"   href="https://eluxjs.com/guide/concepts.html" >https://eluxjs.com/guide/concepts.html<i class="fas fa-external-link-alt"></i></a>.</p><p>微模块是一种集合，也是一个文件夹</p><ul><li>划分视角: <code>业务功能</code>（非UI区域）</li><li>划分原则: <code>高内聚、低耦合</code>（模块之间应当松散，相关资源应当集中）</li></ul><h3 id="目前流行的方案"><a class="markdownIt-Anchor" href="#目前流行的方案"></a> 目前流行的方案</h3><h4 id="yarn-方案"><a class="markdownIt-Anchor" href="#yarn-方案"></a> Yarn 方案</h4><p><a class="link"   href="https://yarnpkg.com/features/workspaces" >Workspaces | Yarn - Package Manager<i class="fas fa-external-link-alt"></i></a></p><h4 id="pnpm-workspace"><a class="markdownIt-Anchor" href="#pnpm-workspace"></a> Pnpm-workspace</h4><p><code>pnpm</code> 实现了依赖之间使用软链进行链接，从而减少了如同黑洞般的 <code>node_modules</code>，这也使得我们在 <code>npm install</code> 的时候速度嗖嗖的。除此之外，<code>pnpm</code> 还提供了 <code>workspace</code> 能力。</p><p><a class="link"   href="https://pnpm.io/zh/workspaces" >工作空间（Workspace） | pnpm<i class="fas fa-external-link-alt"></i></a></p><p>除了基本的 <code>workspace</code> 包管理工具, 还需要版本管理工具, 用于自动化版本更新. 比如 <code>lerna</code>, <code>rush</code> , <code>changelist</code>.</p><h3 id="进一步拓展应用"><a class="markdownIt-Anchor" href="#进一步拓展应用"></a> 进一步拓展应用</h3><ol><li>逐步搭建自己的组件库. 让组件库能渐进式增长 (《人月神话》，产品应该是增长型的)。</li><li>借助自动化工具，或打包工具，实现文档归集，逐步完善， 比如 <code>storybook</code> 。</li><li>为组件库逐步赋能。<br />这里放一个自己的例子: <a class="link"   href="https://couriourc-monorepo.netlify.app/" >Storybook<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://github.com/couriourc/monorepo-playground" >GitHub-monorepo-playground<i class="fas fa-external-link-alt"></i></a>。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;monor</summary>
      
    
    
    
    <category term="公司经历以及问题记录" scheme="http://example.com/categories/%E5%85%AC%E5%8F%B8%E7%BB%8F%E5%8E%86%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="项目中问题记录" scheme="http://example.com/categories/%E5%85%AC%E5%8F%B8%E7%BB%8F%E5%8E%86%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>雅句</title>
    <link href="http://example.com/posts/14NCYJ9.html"/>
    <id>http://example.com/posts/14NCYJ9.html</id>
    <published>2024-12-31T14:45:02.451Z</published>
    <updated>2024-12-31T14:45:02.451Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="滚蛋吧肿瘤君"><a class="markdownIt-Anchor" href="#滚蛋吧肿瘤君"></a> 《滚蛋吧，肿瘤君》</h2><ol><li>抓紧有限的生命，燥起来!哪怕是冲动，也就后悔一阵子。但要是活的太怂了，就会后悔一辈子。</li><li>不要害怕死亡，死亡只是结果。人不能因为害怕失去，就不去拥有。</li><li>听一场摇滚，和耳朵一起一醉方休；喝一圈烈酒，让酒腻子们闻风丧胆；开一场 cosplay party，二次元万岁；摸一下大蜥蜴，我熊胆威风凌厉；吃三斤驴打滚，翻滚吧肠胃；飚一把摩托车，成为风驰电掣的女王；见一下微博红人，感受马伯庸亲王的慈祥；至少学会一样乐器，为喜欢的人弹；种一次昙花，守望者它盛开；做一桌丰盛的晚餐给爸妈，哪怕色不香，味不美；来一次夜钓，吸取月光静臆的能量；仰望喀纳斯的星空，寻找属于我的星座；沐浴漠河的极光，感受它的神秘；去山顶看一次日出，然后大喊滚蛋吧肿瘤君。</li><li>反正开不开心，都是活一天，那就大摇大摆地活呗。</li><li>经历过，爱过，坚强过，战胜过自己，有过这些过程，才算没有白活过呢。</li></ol><h2 id="当幸福来敲门"><a class="markdownIt-Anchor" href="#当幸福来敲门"></a> 《当幸福来敲门》</h2><ol><li>Chris Gardner：You have a dream, you got to protect it.</li><li>Chris Gardner：People can’t do something by themselves; they wanna tell you you can not do it.</li><li>There is an I in “happiness”,There is no Y in “happiness”,It’s an I.</li><li>I’m the type of person,if you ask me a question, and I don’t know the answer,I’m gonna to tell you that I don’t know.But I bet you what: I know how to find the answer, and I’ll find the answer.</li><li>You got a dream, you gotta protect it. People can’t do something themselves,they wanna tell you you can’t do it.If you want something, go get it. Period.</li></ol><h2 id="一念天堂"><a class="markdownIt-Anchor" href="#一念天堂"></a> 《一念天堂》</h2><ol><li>我演过那么多角色，看过那么多人生风景。没有留恋，也没有牵挂。了无痕迹就是最好的表演。是时候告别这个舞台了。</li><li>每场戏都有落下帷幕的时候，每个角色都有告别演出的一天。有的演出冗长而无味，有的演出短暂却精彩。</li><li>人生如戏，这一生努力的将每一个角色扮演的完美，待情节落幕，却发现忘了演自己。</li></ol><h2 id="飞驰人生"><a class="markdownIt-Anchor" href="#飞驰人生"></a> 《飞驰人生》</h2><ol><li>你呢，是这一辈子没故事，想拥有一点儿故事，我呢，是故事太多，想给故事一个结局。</li><li>五年前，我跌入人生的低谷，是你们，写出了各种文章，真真假假，把我扒光示众，扇动大家不要原谅我，让我又多跌了几米。今天，我要把曾经失去的那些尊严，一个一个再夺回来，我张弛，过了这道门，就是回来了。</li><li>成年人的崩溃是从借钱开始的。</li><li>只有当一个人对自己失去信心的那一刻，他才是真的过时了。</li><li>我的一半人生，冷暖就让我自己过问。</li><li>有的人活的是造型 有的人活的是人设 而我活的是本事。</li></ol><h2 id="夏洛特烦恼"><a class="markdownIt-Anchor" href="#夏洛特烦恼"></a> 《夏洛特烦恼》</h2><ol><li>有些人缺铁，有些人缺钙，我缺的是面子。</li><li>一次就好,我陪你去看天荒地老,在阳光灿烂的日子里开怀大笑,在自由自在的空气里吵吵闹闹,你可知道,我唯一的想要. 世界太小,我带你去到天涯海角,在没有烦恼的角落里停止寻找,在无忧无虑的时光里慢慢变老,你可知道,我全部的心跳都随你跳.</li><li>我跳过楼，脑袋可不好使，就特么跟谁脑袋好使似的。</li></ol><h2 id="何以为家"><a class="markdownIt-Anchor" href="#何以为家"></a> 《何以为家》</h2><ol><li>生活是一堆狗屎，不比我的鞋子值钱。</li><li>我以为我们能做个好人，被所有人爱，但上帝不希望我们这样，他宁愿我们做洗碗工。</li><li>我曾经以为我们长大了，就会变成好人，受人尊敬和爱戴。但是上帝不想让我们变成那样，他要我们当地毯，供人踩踏。</li><li>我只记得暴力、侮辱、殴打，链子、管子、皮带。我听过最温柔的一句话是：“滚，你这狗娘养的。滚，你这垃圾。”</li></ol><h2 id="李茶的姑妈"><a class="markdownIt-Anchor" href="#李茶的姑妈"></a> 《李茶的姑妈》</h2><ol><li>无法掌控自己体重的人，怎么掌控自己的人生。</li><li>尊严丢了，整个人就破产了。</li><li>人生七十古来稀，十年少小，十年老弱，再除去上班睡觉吃喝拉撒，好日子着实不多，及时行乐！</li></ol><h2 id="陈翔六点半之民间高手"><a class="markdownIt-Anchor" href="#陈翔六点半之民间高手"></a> 《陈翔六点半之民间高手》</h2><ol><li>想不负此生，首先就得不负身边人。</li><li>年轻的时候，以为人生很长，其实人生很短，最棒的是不后悔，最难的是不遗憾。</li><li>我以前希望自己无牵无挂，潇潇洒洒，不负此生，现在才明白，想不负此生，首先就得不负身边人，我要去完成一件我必须完成的事，希望到时候，我能和所有人坦然相见，再见了，大家。</li></ol><h2 id="只有我不存在的城市"><a class="markdownIt-Anchor" href="#只有我不存在的城市"></a> 《只有我不存在的城市》</h2><ol><li>未来总是一张白纸，只有自己的意志，才能在上面刻下足迹。</li><li>善行和恶行的本质都是相同的，只不过是人类为了弥补自己的缺陷所付出的行动罢了。</li><li>鼓起勇气采取行动的结果怎么可以是"悲剧"呢？</li><li>开心的事情、悲伤的事情，还有成功与失败，你们的小学生涯到此就结束了，大家都还有各种各样的不足，包括我也是，但是，填补这些不足才称得上是人生。我是这么认为的。</li><li>我们无时无刻都想着回到记忆中的童年，找到那时候还没丢掉的天真，可是，曾几何时我们做出童年般的事，嘴角露出一丝微笑，心中却似乌云密布。</li><li>"如果当时这么做就好了"这句话每天都萦绕于心。但是，它并没有化作真切的悔意，只是转瞬即逝的托词罢了。</li><li>大家都是为了在得到什么的过程中，忍受着、努力着，掌握了一些能力，来让自己振奋起来。</li><li>“相信"还真是句奇怪的话呢，因为若是发自真心的信任，根本不需要说出"相信"这样的话吧，只需意会，不必言传。因为有所怀疑，所以才会相信……是这个意思吗？尽管如此，我也不想承认，“相信"这种话感觉像是在撒谎。所谓"相信”，就是"想要相信”……这样充满希望的话语哦。</li><li>我一直在扮演，想要朋友，想要和人亲近，想着不擅长和人接触的自己究竟能做些什么呢？最后决定自己去喜欢大家，这样扮演也变得轻松了不少。</li></ol><h2 id="小偷家族"><a class="markdownIt-Anchor" href="#小偷家族"></a> 《小偷家族》</h2><ol><li>自己做出的选择，才能建立更牢靠的羁绊。</li><li>他们说喜欢你才会打你，是假的。真正喜欢你，会像这样，抱着你。</li><li>萍水相逢的凡人之间，也可以有真挚深沉的羁绊，这羁绊，是我们活下去的全部理由。</li><li>难道生下了孩子，你就自然能成为母亲吗？</li><li>没有扔掉，只是捡来了。最开始扔掉的人应该别有所在吧。</li><li>烟花未曾照耀的地方，也有仰望着的笑脸，生活沉重如此，仰望本身，即是美丽。</li></ol><h2 id="弥留之国的爱丽丝"><a class="markdownIt-Anchor" href="#弥留之国的爱丽丝"></a> 《弥留之国的爱丽丝》</h2><ol><li>某天突然注意到，我在这个世界里既不是勇者也不是魔法师，更不是玩家，只是是个普通的村民甲。</li><li>为什么会这么美丽，这就是命运。在死亡来临前的最后一刻为止，只是为了活下去，这就是属于生命的光辉吗？</li><li>我们活着这件事，并不单纯只是维持生命，是生命痕迹的相互交错啊。</li></ol><h2 id="白夜行"><a class="markdownIt-Anchor" href="#白夜行"></a> 《白夜行》</h2><ol><li>绝望的念想，非恸的守望。</li><li>唯有那家图书馆，才是他们两人的心灵休憩之处。他们只是想保护自己的灵魂。</li><li>"恶魔不会因为你是孩子就放过你，而且，恶魔还不止一个。"杀死恶魔的人，必定也被恶魔的鲜血所污染，自己也变成了恶魔。</li><li>曾经拥有的东西被夺走，并不代表就会回到原来没有那种东西的时候。</li><li>捡别人的东西不还跟偷别人随意放置的东西没有什么差别。有错的难道不是把装了钱的包随便放的人吗？在这个社会上，让别人有机可乘的人注定要吃亏。</li><li>所有的守护，只为你一人在阳光下行走。</li><li>你是我的…太阳，火热的太阳，不放弃在明天继续升起，这是我唯一的希望。</li><li>我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。我从来就没有太阳，所以不怕失去。</li><li>她的眼神里有一种微妙得难以言喻的刺。但那并不是社交舞社社长无视她的存在，只顾和朋友讲话而自尊受伤的样子。那双眼睛里栖息的光并不属于那种类型。那是更危险的光——这才是一成的感觉，可以说是隐含了卑劣下流的光。他认为真正的名门闺秀，眼神里不应栖息着那样的光。</li><li>她唯一一次没有伪装，是在光芒熄灭的时候。从此，只剩她一个人，行走在永夜。</li><li>世上有两样东西不可直视，一是太阳，二是人心。</li><li>一天当中有太阳升起的时候，也有下沉的时候。人生也一样。有白天和黑夜，只是不会像真正的太阳那样，有定时的日出和日落。看个人，有些人一辈子都活在阳光的照耀下，也有些人不得不一直活在漆黑的深夜里。人害怕的，就是本来一直存在的太阳落下不再升起，也就是非常害怕原本照在身上的光芒消失。我的天空里没有太阳总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮。但对我来说已经足够。，凭借这份光，我便能把黑夜当成白天。我从来就没有太阳，所以不怕失去。</li><li>请告诉孩子们，真正的惩罚是会留在心和记忆里面的，吞下的罪恶侵蚀着灵魂，不久之后，连那身体，连生命也都被吃尽了，请在那之前，请转达给父母们，来自一个幽灵的遗言。</li><li>有些人一辈子都活在太阳的照耀下，也有些人不得不一直活在漆黑的深夜里。人害怕的，就是本来就一直存在的太阳落下不再升起，也就是非常害怕原本照在身上的光芒消失。</li></ol><h2 id="京剧猫"><a class="markdownIt-Anchor" href="#京剧猫"></a> 《京剧猫》</h2><ul><li>只要有信念，就一定能成功。 --白糖</li><li>只要有信念，就可以成为强者。 --修</li><li>世界万物都是平等的。 --白糖/金婆婆</li><li>既是相克，必然相生。 --银婆婆</li><li>路是一步一步走出来的，好吃的也是一口一口吃出来的。</li><li>忠于自己的信念，是我们猫的品格。</li><li>虽然我们只是普通的猫，但我们有着非凡的勇气和毅力。</li><li>做人要像猫，勇敢、不屈不挠；做事要像猫，敏捷、忠诚、忠于自己的信念。</li><li>修也好，锣楼也好。–白糖</li><li>混沌就一定是邪恶的吗？韵是万物的本源，混沌亦是万物之一，二者一脉，若说混沌必定邪恶，那来自万物的韵是否又包含了邪恶？</li><li>每一场战斗，都是一次机会，一次为了荣誉、自由和正义而战的机会。"——猫武士</li><li>有困难要上，有难兄难弟要帮，有难猫难狗要拦。</li><li>将不死，总有再战之日。</li><li>在猫武士的世界里，没有哪一只猫是毫无用处的。每一个猫都有他们独特的价值和贡献。"——猫武士</li><li>即使记忆被抹去，朝夕相处的证明却不会因此而消失。</li><li>一个放弃自己的人 和垃圾有什么区别</li><li>我会永远记得你的心跳声</li><li>拂袖睁明眸 一曲唱罢喜与忧 功名难就 跌宕或常有 剑在手与子同仇 历寒暑春秋 且落笔挥斥方遒 唱古韵清幽 与天地共长久</li><li>摧毁一份信任简单，但要挽回，何其困难。—散白</li><li>“要不你当我妹妹吧” “你终于喊我姐姐了” —— 墨紫</li><li>“你可知 比仇恨更难忘的 是什么 是伤心”</li><li>声如洪钟，气如游丝，振钧而生，谐律而起。 —— 白糖</li><li>妈妈，有相亲相爱的夫君 妹妹，有同生共死的伙伴 墨紫，什么都没有……—— 墨紫</li><li>未知世界虽无尽，爱的道路有无穷。</li><li>理想 愿望 这些都没有错 错就错在 没有力量的你 无论如何咬牙坚持 到头来 依旧只能陷入无奈的被动 和无尽的悔恨当中 —— 黯(混沌之主)</li><li>一面为善，一面为恶，没有人的内心是永远善良的，就看你是不是能坚持从善的信念，说起来简单，可又有多少人能做到呢？</li><li>曲而不折，去而复返，流水通幽，势如破海——“京剧猫”</li><li>只要有信念就一定会成功</li><li>太阳当空照，肚子咕咕叫。走了多远不知道，快要饿死了。</li><li>这世间只有因果 何来是非</li><li>信任一旦被摧毁，在建立起来就难了</li><li>我呀，就想喊声妈妈，可惜我没有，别留遗憾哦</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;滚蛋吧肿瘤</summary>
      
    
    
    
    <category term="闲情雅致" scheme="http://example.com/categories/%E9%97%B2%E6%83%85%E9%9B%85%E8%87%B4/"/>
    
    <category term="闲情雅致" scheme="http://example.com/categories/%E9%97%B2%E6%83%85%E9%9B%85%E8%87%B4/%E9%97%B2%E6%83%85%E9%9B%85%E8%87%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>旅游</title>
    <link href="http://example.com/posts/26BENS9.html"/>
    <id>http://example.com/posts/26BENS9.html</id>
    <published>2024-12-31T14:45:02.450Z</published>
    <updated>2024-12-31T14:45:02.450Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="成都市"><a class="markdownIt-Anchor" href="#成都市"></a> 成都市</h2><ul><li>武侯区：武侯祠，锦里，玉林，环球中心</li><li>青羊区：杜甫草堂，宽窄巷子，金沙遗址，文殊院，人民公园</li><li>金牛区：欢乐谷，植物园，凤凰山</li><li>成华区：建设路小吃街，熊猫基地，东郊记忆，动物园，龙潭水乡，339</li><li>龙泉驿区：龙泉山，东安湖，金龙长城，洛带古镇，青龙湖</li><li>锦江区：春熙路，太古里</li><li>天府新区、双流：麓湖，兴隆湖，空港公园</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;成都市&quot;&gt;</summary>
      
    
    
    
    <category term="闲情雅致" scheme="http://example.com/categories/%E9%97%B2%E6%83%85%E9%9B%85%E8%87%B4/"/>
    
    <category term="闲情雅致" scheme="http://example.com/categories/%E9%97%B2%E6%83%85%E9%9B%85%E8%87%B4/%E9%97%B2%E6%83%85%E9%9B%85%E8%87%B4/"/>
    
    
    <category term="生活" scheme="http://example.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="旅游" scheme="http://example.com/tags/%E6%97%85%E6%B8%B8/"/>
    
    <category term="计划" scheme="http://example.com/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>computer-principle-overview</title>
    <link href="http://example.com/posts/261MFT9.html"/>
    <id>http://example.com/posts/261MFT9.html</id>
    <published>2024-12-31T14:45:02.445Z</published>
    <updated>2024-12-31T14:45:02.445Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><strong>原码</strong>：将最高位作为符号位（0表示正，1表示负），其它数字位代表数值本身的绝对值的数字表示方式。</p><p><strong>反码</strong>：如果是正数，则表示方法和原码一样；如果是负数，符号位不变，其余各位取反，则得到这个数字的反码表示形式。</p><p><strong>补码</strong>：如果是正数，则表示方法和原码一样；如果是负数，则将数字的反码加上1（相当于将原码数值位取反然后在最低位加1）。</p><blockquote><p>tips: 以上的说法是对于二进制，可以知道补码的含义是</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>P</mi><msub><mo stretchy="false">]</mo><mtext>原</mtext></msub><mo>+</mo><mo stretchy="false">[</mo><mi>Q</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub><mo>=</mo><msup><mi>K</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">[P]_原+[Q]_补=K^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">Q</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> K表示几进制，n 表示有几位</p><p>比如一位十进制的补码</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>P</mi><msub><mo stretchy="false">]</mo><mtext>原</mtext></msub><mo>+</mo><mo stretchy="false">[</mo><mi>Q</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">[P]_原+[Q]_补=10^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">Q</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></p></blockquote><h2 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h2><table><thead><tr><th>真值</th><th>原码</th><th>反码</th><th>补码</th></tr></thead><tbody><tr><td>58</td><td>0111010</td><td>0111010</td><td>0111010</td></tr><tr><td>-58</td><td><span class="text-red">1</span>111010</td><td>1<span text-red="">000101</span></td><td>10001<span text-red="">10</span></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;&lt;strong&gt;原码</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机基础知识" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机组成原理" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机基础" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机组成原理" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>data-structure-concept</title>
    <link href="http://example.com/posts/3179MNW.html"/>
    <id>http://example.com/posts/3179MNW.html</id>
    <published>2024-12-31T14:45:02.438Z</published>
    <updated>2022-11-06T07:08:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="绪论"><a class="markdownIt-Anchor" href="#绪论"></a> 绪论</h2><p><strong>数据：</strong> 数据是信息的载体，信息是数据的内涵。</p><p><strong>数据元素：</strong> 数据的基本单位。</p><p><strong>数据项：</strong> 构成数据元素不可分割的最小单位。</p><p><strong>数据对象：</strong> 性质相同的数据元素的集合，是数据的子集。</p><p><strong>数据类型：</strong> 一个值的集合以及定义在此集合上一组操作的总称。原子类型、结构类型、抽象数据类型 ADT。</p><p><strong>抽象数据类型 ADT：</strong> 只关心逻辑结构，无需关系具体实现、存储结构。由数据对象、数据关系、基本操作组成。</p><p><strong>数据结构：</strong> 相互之间存在一种或多种特定关系的数据元素的集合。数据结构=数据元素+数据关系。</p><p><strong>数据结构三要素：</strong> 逻辑结构、物理结构、数据运算。</p><p><strong>逻辑结构：</strong> 数据元素之间的逻辑关系。线性结构、非线性结构。</p><p><strong>线性结构</strong>：线性表1:1、栈、队列、串、数组、广义表。</p><p><strong>非线性结构</strong>：集合，除同属一个集合别无其他关系;树，1:n;图，m:n。</p><p><strong>存储结构：</strong> 数据结构在计算机上的表示，顺序存储、链式存储、索引存储、散列存储。</p><p><strong>数据运算：</strong> 运算的定义依赖于逻辑结构，运算的实现依赖于物理结构。</p><p><strong>算法：</strong> 特定问题求解步骤的描述。</p><p><strong>算法五特性：</strong> 确定性、可行性、有穷性、输入、输出。</p><p><strong>优质算法特性：</strong> 正确性、健壮性、可读性、高效率、低存储（时空复杂度低）。</p><p><strong>算法分析：</strong> 时间复杂度、空间复杂度、稳定性。</p><p><strong>S(n)=O(1):</strong> 算法原地工作指算法所需要的辅助空间为常量。</p><p><strong>程序=数据结构+算法：</strong> 数据结构是要处理的信息，算法是处理信息的步骤。</p><hr><h2 id="线性表"><a class="markdownIt-Anchor" href="#线性表"></a> 线性表</h2><p><strong>顺序表：</strong> 线性表的顺序存储，逻辑顺序和物理顺序相同。随机访问，存储密度高，插入删除需要移动大量元素。静态顺序表、动态顺序表。<br>静态线性表：数组、大小固定、少则内存溢出、多则资源浪费。<br>动态线性表：动态分配存储空间。</p><p><strong>链表：</strong> 线性表的链式表示，不要求存储地址联系，失去了随机访问的特性。适合插入删除。单链表、双链表、循环链表、静态链表。</p><p><strong>单链表：</strong> 链表结点存放后继指针。访问后继结点时间复杂度为 O(1),前驱为 O(n)。</p><p><strong>双链表：</strong> 链表结点存放前驱和后继指针，这样就克服了单链表不能从后往前遍历的缺陷。prior、next</p><p><strong>循环链表：</strong> 循环单链表、循环双链表。循环单链表需要将尾结点指针指向头结点，这样就可以形成环。循环双链表还需要将头结点的 prior 指针指向尾结点。</p><p><strong>静态链表：</strong> 借助数组实现的链表。</p><p><strong>线性表基本操作：</strong> 创销、CRUD、判空、判表长、输出。</p><p><strong>线性结构和非线性结构区别：</strong> 线性结构除第一个和最后一个节点外，其余结点有唯一前驱和后继，第一个节点无前驱，最后一个结点无后继，结点之间是一对一关系。非线性结构结点前驱后继不具有唯一性，结点之间关系为一对多或者多对多。</p><p><strong>顺序存储结构特点：</strong> 存储密度大，空间利用率高；随机访问，随机存取；不适合插入删除操作，因为需要移动大量元素；预分配存储空间难以确定。</p><p><strong>顺序存储结构与链式存储结构比较</strong></p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">顺序存储结构</th><th style="text-align:left">链式存储结构</th></tr></thead><tbody><tr><td style="text-align:left">优点</td><td style="text-align:left">存储密度高、随机访问、随机存取</td><td style="text-align:left">插入删除方便、动态分配存储空间、空间利用率高</td></tr><tr><td style="text-align:left">缺点</td><td style="text-align:left">不适合插入删除，因为需要移动大量元素；预分配存储空间难以确定</td><td style="text-align:left">存储密度小、访问需要从头遍历链表</td></tr></tbody></table><p><strong>顺序表和链表的比较</strong></p><table><thead><tr><th style="text-align:left">区别</th><th style="text-align:left">顺序表</th><th style="text-align:left">链表</th></tr></thead><tbody><tr><td style="text-align:left">存储结构</td><td style="text-align:left">顺序存储</td><td style="text-align:left">链式存储</td></tr><tr><td style="text-align:left">存取/访问速率</td><td style="text-align:left">随机存取，随机访问，方便O(1)</td><td style="text-align:left">不方便，需要遍历O(n)</td></tr><tr><td style="text-align:left">存储密度</td><td style="text-align:left">高</td><td style="text-align:left">低</td></tr><tr><td style="text-align:left">插入删除</td><td style="text-align:left">不方便，需要移动大量元素</td><td style="text-align:left">方便，修改指针</td></tr></tbody></table><p><strong>数组和链表的比较</strong></p><table><thead><tr><th style="text-align:left">区别</th><th style="text-align:left">数组</th><th style="text-align:left">链表</th></tr></thead><tbody><tr><td style="text-align:left">分配空间</td><td style="text-align:left">静态分配/栈分配</td><td style="text-align:left">动态分配/堆分配</td></tr><tr><td style="text-align:left">访问速率</td><td style="text-align:left">根据数组下标直接访问</td><td style="text-align:left">从头遍历</td></tr><tr><td style="text-align:left">插入删除</td><td style="text-align:left">不方便，需要移动大量元素</td><td style="text-align:left">方便，只需修改指针</td></tr></tbody></table><p><strong>头指针和头结点区分</strong></p><table><thead><tr><th style="text-align:left">区分</th><th style="text-align:left">头指针</th><th style="text-align:left">头结点</th></tr></thead><tbody><tr><td style="text-align:left">概念</td><td style="text-align:left">指向链表第一个结点的指针</td><td style="text-align:left">带头结点链表的第一个结点，是链表在表头附加的结点</td></tr><tr><td style="text-align:left">是否必须</td><td style="text-align:left">是</td><td style="text-align:left">否，只是为了统一操作</td></tr><tr><td style="text-align:left">引入头结点作用</td><td style="text-align:left">头指针就是链表名字、标记链表</td><td style="text-align:left">空表非空表头结点都指向头结点/统一了第一个数据结点和其余结点的操作</td></tr></tbody></table><p><strong>单链表双链表的区别</strong></p><table><thead><tr><th style="text-align:left">单链表</th><th style="text-align:left">双链表</th></tr></thead><tbody><tr><td style="text-align:left">存放后继指针next ,只能从前往后遍历</td><td style="text-align:left">存放前驱后继指针prior、next，双向遍历</td></tr></tbody></table><hr><h2 id="受限线性表特殊线性表栈-队列-串"><a class="markdownIt-Anchor" href="#受限线性表特殊线性表栈-队列-串"></a> 受限线性表/特殊线性表（栈、队列、串）</h2><p><strong>栈：</strong> 限定表尾插入删除，顺序栈、链栈、共享栈。</p><p><strong>顺序栈：</strong> 栈的顺序表示。</p><p><strong>链栈：</strong> 栈的链式存储。</p><p><strong>共享栈：</strong> 两个栈共享同一片空间。</p><p><strong>队列：</strong> 一段插入、一段删除，顺序队列（循环队列）、链队、双端队列。</p><p><strong>循环队列：</strong> 把顺序队列的尾指针指向头结点形成环。</p><p><strong>链队：</strong> 队列链式存储。</p><p><strong>双端队列：</strong> 两端都可以插入删除的队列。</p><p><strong>输入受限的双端队列：</strong> 只允许一端插入，两端删除。</p><p><strong>输出受限的双端队列：</strong> 只允许一端删除，两端插入。</p><p><strong>串：</strong> 限制数据元素为字符的线性表。</p><p><strong>串的存储结构：</strong> 定长顺序存储、堆分配、块链存储。</p><p><strong>串的模式匹配：</strong> 暴力匹配算法、KMP、改进 KMP。</p><p><strong>栈的应用：</strong> 括号匹配、表达式求值、递归。</p><p><strong>队列应用：</strong> 图的广度优先遍历，树的层次遍历，FCFS 先来先服务。</p><p><strong>多栈共享技术：</strong> 两栈共享空间、利用“栈底位置不变、栈顶动态变化”特性。</p><p><strong>串和线性表的区别？</strong> 串是特殊线性表，限制数据元素为字符，并且串的操作和线性表有较大差别，线性表操作大多以数据元素为操作对象，而串大多以串的整体或模式串作为操作对象。</p><p><strong>简述 KMP 算法</strong>：KMP 算法是在简单模式匹配算法的基础上对串的模式匹配进行优化。也就说 KMP 是改进的暴力匹配算法。</p><ul><li>主要的思路是每趟比较过程中让子串先滑动到一个合适的位置。</li><li>当发生不匹配时，不同于简单模式匹配的右移一位，而是移动到适合的位置。</li><li>这里所移动的位置依靠 <code>next[]</code> 数组，求 <code>next[]</code> 数组的方法是比较前后缀相同元素。</li></ul><p><strong>栈和队列区别</strong></p><table><thead><tr><th style="text-align:left">栈</th><th style="text-align:left">队列</th></tr></thead><tbody><tr><td style="text-align:left">先入后出</td><td style="text-align:left">先入先出</td></tr><tr><td style="text-align:left">只许表尾插入删除</td><td style="text-align:left">一段插入一段删除</td></tr></tbody></table><hr><h2 id="线性表推广数组-广义表"><a class="markdownIt-Anchor" href="#线性表推广数组-广义表"></a> 线性表推广（数组、广义表）</h2><p>**数组：**相同数据类型的数据元素的有限序列。</p><p>**矩阵：**二位数组即矩阵，数组可以是数字、字符等，矩阵数据元素只能是数字。对称矩阵、对角矩阵、三角矩阵、三对角矩阵、稀疏矩阵。按行优先存储、按列优先存储。</p><p>**压缩存储：**相同数值分配一个存储空间、零不分配存储空间，目的节约存储空间。</p><p>**稀疏矩阵：**绝大部分数据元素为0的矩阵，通过三元组压缩存储。但压缩存储后失去了随机存取的特性。稀疏矩阵的三元组既可以采用数组存储,也可以采用十字链表存储。</p><p>**广义表:**放松了对表元素原子性的限制,容许表元素有自身结构。</p><hr><h2 id="树"><a class="markdownIt-Anchor" href="#树"></a> 树</h2><p><strong>二叉树：</strong> 结点的度最多为二，有左右子树之分。</p><p><strong>完全二叉树：</strong> 结点从上到下，从左到右。</p><p><strong>满二叉树：</strong> 每一层结点数都达到最大值。特殊的完全二叉树。</p><p><strong>二叉排序树 BST：</strong> 左子树所有结点值小于根值，右大于根，也可以为空树。</p><p><strong>平衡二叉树 AVL：</strong> 改进的二叉排序树，平衡因子不大于1。</p><p><strong>平衡调整：</strong> LL 调整、RR 调整、LR 调整、RL 调整。</p><p><strong>B-树：</strong> 平衡二叉树扩展，结点多关键字的平衡树。</p><p><strong>B+树：</strong> B-树的变形，叶子结点存储关键字以及记录地址，非叶子结点只有索引作用。</p><p><strong>B-树和 B+树区别：</strong> B-树分支从关键字两端引出、B+树分支从关键字引出；B-树中每个结点都存储信息，B+树只有根节点存储关键字和记录，非叶结点只有索引作用，另外 B+树可以用指针指向关键字最小的结点，并把所有结点链接成单链表。</p><p><strong>哈夫曼树：</strong> 树的带权路径长度最小的二叉树，也称最优二叉树。</p><p><strong>遍历二叉树：</strong> 按某种搜索路径寻访二叉树每个结点，使得每个结点只被访问一次。</p><p><strong>线索二叉树：</strong> 可以像遍历单链表一样遍历二叉树，加快查找前驱和后继结点。</p><p><strong>二叉树存储结构：</strong> 顺序存储结构、链式存储结构；完全二叉树和满二叉树采用顺序存储，其他二叉树如需要顺序存储需要添加空结点，一般二叉树采用链式存储结构。</p><p><strong>树的三种存储方法：</strong> 孩子表示法、双亲表示法、孩子兄弟表示法。</p><p><strong>树的遍历：</strong> 先序遍历，后续遍历<br><strong>二叉树遍历：</strong> 先序遍历，中序遍历，后续遍历，层次遍历</p><p><strong>树、森林、二叉树的转换：</strong> 左孩子右兄弟</p><p><strong>树的应用-并查集：</strong> 管理一些不相交集合，并支持两种操作，合并和查询，其重要思想在于用集合中一个元素代表整个集合。</p><p><strong>简述哈夫曼树的</strong> 主要内容分为概念、性质、构造、哈夫曼编码、平均码长、作用。<br><strong>概念：</strong> 哈夫曼树是 WPL 最小的二叉树，也称最优二叉树。<br><strong>性质：</strong> 离根越近结点权值越大，没有度为0的结点，原结点都是叶子结点，结点总数2n-1，度为二的结点数为 n-1。<br><strong>构造：</strong> 将集合中两个权值最小的结点相加结合生成一个新节点，放入集合，把原来的两个结点删除，在找两个最小的结点重复进行。</p><p><strong>哈夫曼编码：</strong> 可变长最短前缀编码。<br><strong>平均码长：</strong> 各初始结点权值乘路径长度的总和。 <strong>作用：</strong> 数据压缩</p><hr><h2 id="图"><a class="markdownIt-Anchor" href="#图"></a> 图</h2><p><strong>有向边、无向边：</strong> 有向边是弧，无向边是边。</p><p><strong>完全图：</strong> 该有的边都有，有向完全图边的个数为 n(n-1),无向完全图边的个数为 n(n-1)/2。</p><p><strong>简单图，多重图：</strong> 是否有自环和平行边。</p><p><strong>连通图、强连通图：</strong> 有向图任意两个顶点都有路径相通，无向图任意两点之间都有来回路径。</p><p><strong>极大连通子图、极小连通子图、极大强连通子图、极小强连通子图：</strong> 极大连通子图即连通分量，极小连通子图即边最少的连通子图，极大强连通子图即强连通分量、极小强连通子图在保持任意两结点来回互通的情况下弧最少的连通子图。</p><p><strong>生成树：</strong> 无向图的一个极小连通子图。</p><p><strong>图的遍历：</strong> 从某一顶点按需访问图中所有结点，每个结点只被访问一次。</p><p><strong>DAG：</strong> 有向无环图，包括 AOE 和 AOV。</p><p><strong>AOE：</strong> 以弧为活动，顶点表示事件的有向网。边有权值，用于关键路径。</p><p><strong>AOV：</strong> 以顶点表示活动、弧表示事件的有向网。边无权值，用于拓扑排序。</p><p><strong>图的存储结构：</strong> 邻接矩阵、邻接表、十字链表、邻接多重表。</p><p><strong>邻接矩阵：</strong> 适用于稠密图，对称矩阵。包含顶点集和边集。</p><p><strong>邻接表：</strong> 适用于稀疏图，通过顶点表和边表组成。顶点表顺序，边表链式。有向图邻接表和逆邻接表的结合。</p><p><strong>十字链表：</strong> 适用于有向图，对邻接表查找入度的改进，方便快速查找入度。</p><p><strong>邻接多重表：</strong> 适用于无向图，对邻接表删除一个结点需要删除两个边表结点。</p><p><strong>图的遍历：</strong> 深度优先遍历 DFS、广度优先遍历 BFS。</p><p><strong>DFS:</strong> 类似于树的先序遍历。工作栈实现，从初始点 v 开始访问任意一个未被访问的邻接顶点 m1，顶点 m1访问一个未被访问的邻接顶点 m2，依次进行同样操作，直到该顶点没有未被访问的邻接顶点，则返回上一层，重复操作。</p><p><strong>BFS:</strong> 类似于树的层次遍历。队列+辅助数组，从初始点出发，访问所有邻接顶点 m1,m2…然后依次访问 m1未被访问的邻接顶点，m2未被访问的邻接顶点…重复上述操作。</p><p><strong>最小生成树:</strong> 无向网中边权值之和最小的生成树，最小生成树 MST 不一定唯一。prim、克鲁斯卡尔。</p><p><strong>Prim：</strong> 从点找边，先将初始点放入结果集，从初始顶点出发找到一个未被访问的权值最小的边所邻接的顶点，放入结果集，然后再找和这两个顶点未被访问的权值最小边所邻接顶点，放入集合，依次进行。</p><p><strong>克鲁斯卡尔：</strong> 从边找点，先找一个权值最小的边，然后找与这个边上顶点所邻接的最小边，这之间不能形成环，依次进行。</p><p><strong>最短路径：</strong> 迪杰斯特拉、弗洛伊德。</p><p><strong>克鲁斯卡尔：</strong> 求单源最短路径。</p><p><strong>弗洛伊德 Floyd：</strong> 求各顶点之间的最短路径。</p><p><strong>拓扑结构：</strong> 将入度为0的顶点取出,可用于检测 AOV 网是否有环。</p><p><strong>关键路径：</strong> 在 AOE 网中，从源点到汇点的最长路径。</p><hr><h2 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h2><p><strong>查找分类：</strong><br>按功能：静态查找表适合查询，如顺序查找，折半查找；动态查找表适合插入删除，如 BST、AVL、B-树、B+树。<br>按结构：线性表、树表、散列表。</p><p><strong>查找表：</strong> 同一类型数据元素的集合。</p><p><strong>线性表查找：</strong> 顺序查找、折半查找、分块查找。</p><p><strong>顺序查找：</strong> 可以对有序表、也可以无序表。适用于顺序和链式存储。</p><p><strong>折半查找：</strong> 对有序表的查找。用到折半查找判定树。适用于顺序存储。</p><p><strong>分块查找：</strong> 顺序查找和折半查找的结合，块内无序、块间有序。</p><p><strong>树表查找：</strong> 二叉排序树、平衡二叉树、B-树、B+树。</p><p><strong>二叉排序树：</strong> 可以为空树，当有左子树，左子树所有结点的值小于根结点的值，若有右子树，则右子树上结点的值大于根值，左子树，右子树同理。</p><p><strong>平衡二叉树：</strong> 二叉排序树的改进，还要求平衡因子不大于1。</p><p><strong>关键字：</strong> 数据元素中某个数据项的值，用它可以标识一个数据元素。</p><p><strong>B-树：</strong> 平衡二叉树的推广，多关键字平衡树。</p><p><strong>B+树：</strong> B-树变形，叶子结点存放关键字和记录地址，非叶子结点只有索引作用，且可以用一个指针指向最小关键字的叶子结点，把各叶子结点链接成单链表。</p><p><strong>散列表：</strong> 根据关键字直接进行访问的数据结构，建立了关键字和物理存储的直接映射。</p><p><strong>散列函数：</strong> 把关键字映射成物理地址的函数。</p><p><strong>散列函数构造方法：</strong> 直接定址法、平方取中法、初留取余法、数字分析法、叠加法。</p><p><strong>冲突：</strong> 不同关键之映射到同一地址的情况。</p><p><strong>解决冲突的方法：</strong> 解决冲突的方法就是解决增量序列的问题。<br>开放定址法：线性探查发、平方探查发、再散列法、伪随机法。不适用于删除，因为删除的数据元素存储位置为空，他后面的数据元素就无法遍历查询到了。平方取中法解决了线性探查发堆积现象。<br>拉链法：通过链表把映射到相同地址的关键字链接存储。适用于插入删除。</p><p><strong>散列查找效率影响因素：</strong> 填装因子，散列函数，处理冲突的方法。平均查找长度 ASL 依赖于填装因子。填装因子是所存储的数据元素和整个申请存储空间的比值，即表的装满程度。</p><p><strong>顺序查找：</strong> 给定的关键字 k 从前往后对比线性表中记录的关键字，如果该几率关键字等于 k，则查找成功，否则查找失败。ASL=3(n+1)/4</p><p><strong>折半查找：</strong> 将给定的关键字和表中中间记录关键字比较，如相等则成功，若小于中间关键字则说明要查找的关键字在表的前半部分，若大于同理，如此进行，直达找到，查找成功，否则查找失败。ASL=log2 (n+1)-1</p><p><strong>分块查找：</strong> 顺序查找或折半查找索引表、顺序查找块内元素。</p><p><strong>散列查找：</strong> 通过散列函数求关键字存储地址，看是否为空，如果空就失败，否则比较该记录关键字，若采用开放定址法则若不等则通过增量序列找到下一个存储地址进行对比，若拉链法，遍历查找链表。</p><hr><h2 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h2><p><strong>算法评价：</strong> 时间空间复杂度、稳定性。</p><p><strong>内部排序、外部排序：</strong> 内部排序利用内存；外部排序内存+外存，适用于大文件。</p><p><strong>排序种类：</strong></p><ol><li><p>插入排序：直接插入排序、希尔排序</p></li><li><p>交换排序：冒泡排序、快速排序</p></li><li><p>选择排序：直接选择排序、堆排序</p></li><li><p>归并排序：二路归并，多路归并排序（外排序）</p></li><li><p>基数排序、计数排序、桶排序</p><p><img lazyload="" src="/images/loading.svg" data-src="/media/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/data-structure-concept/watermark.png" alt="在这里插入图片描述"></p></li></ol><p><strong>排序算法稳定性：</strong> 相同数字在排序前后相对位置不变。<br>不稳定：希尔排序、快速排序、直接选择排序、堆排序<br>不稳定：直接选择排序、冒泡排序、归并排序、基数排序、计数排序、桶排序</p><p><strong>排序算法时间复杂度：</strong></p><ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>：直接插入排序、直接选择排序、冒泡排序</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(nlog_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>：希尔排序、快速排序、堆排序、归并排</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>：基数排序、计数排序、桶排序 <strong>排序算法空间复杂度：</strong></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n)=O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>：直接插入排序、希尔排序、冒泡排序、直接插入排序、堆排序</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n)=O(log_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>：快速排序</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n)=O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>：归并排序</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n)=O( r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>：基数排序</li></ol><p><strong>直接插入排序：</strong> 和打扑克牌一样，把未排序的部分按序取出一个元素插入到已经排序好的有序序列中，插入位置从前往后找。时间复杂度 O(n^2),空间复杂度 O(1)</p><p><strong>希尔排序：</strong> 分组直接插入排序，将排序元素按增量序列分为几组，组内直接插入排序，缩减增量，使得元素基本有序，在进行一次直接插入排序。时间复杂度 O(nlog2 n)，空间复杂度 O(1)</p><p><strong>冒泡排序：</strong> 比较相邻元素的值。时间复杂度 O(n^2),空间复杂度 O(1)</p><p><strong>快速排序：</strong> 从左到右的元素都能一次性找到自己最终位置。piovt 基准，low,high。时间复杂度 O(nlog2 n),空间复杂度 O(log2 n)</p><p><strong>直接选择排序：</strong> 在给定的一组记录中选择最小的和第一个记录交换，然后从第二个记录到最后记录中找最小的和第二个记录交换，如此下去。方式可选小放前面、选大放后面。时间复杂度 O(n^2),空间复杂度 O(1)</p><p><strong>堆排序：</strong> 大根堆、小根堆。时间复杂度 O(nlon2 n),空间复杂度 O(1)</p><p><strong>二路归并排序：</strong> 两两归并，排序成一个个有序序列。时间复杂度 O(nlog2 n),空间复杂度 O(n)</p><p><strong>基数排序：</strong> 实现方法为最高位优先、最低为优先。利用辅助队列按位收集和分配。时间复杂度 O(n),空间复杂度 O(r )</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;绪论&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机基础知识" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="数据结构" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="基础知识" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="概念总结" scheme="http://example.com/tags/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>入不了门一点</title>
    <link href="http://example.com/posts/11229WB.html"/>
    <id>http://example.com/posts/11229WB.html</id>
    <published>2024-12-31T14:45:02.397Z</published>
    <updated>2024-12-31T15:11:55.396Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="format-格式"><a class="markdownIt-Anchor" href="#format-格式"></a> Format 格式</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">target</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,target);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:o&#125;&quot;</span>,target);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:x&#125;&quot;</span>,target);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:X&#125;&quot;</span>,target);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>,target);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:b&#125;&quot;</span>,target);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:e&#125;&quot;</span>,target);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:E&#125;&quot;</span>,target);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,target);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>,target);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;a&#125;&quot;</span>,a=target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量声明"><a class="markdownIt-Anchor" href="#变量声明"></a> 变量声明</h2><p>Rust 变量必须先声明后使用，对于局部变量，最常见的声明语法为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">variable</span>: <span class="type">i32</span> = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><code>Rust</code> 中声明变量缺省是 <strong>只读</strong> 的，比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">x=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>会报错</p></blockquote><p>如果希望变量是可修改的，那么需要使用 <code>mut</code> 关键字：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可修改</p></blockquote><p><code>mut x</code> 是一种 <code>mode</code> 可以描述多个变量。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="keyword">mut</span> a,<span class="keyword">mut</span> b&#125; = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">Point</span> &#123; x :<span class="keyword">ref</span> a,y :<span class="keyword">ref</span> b&#125; = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个变量必须被初始化，才可以使用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>:<span class="type">i32</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>[!TIP]<br />上述代码实际上会报错</p></blockquote><p>初始化的时候可以不需要，<code>mut</code> 修饰，因为是初始化。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>:<span class="type">i32</span>;</span><br><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line">x = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里就不能使用 x 了。</span></span><br><span class="line"><span class="comment">// 两个原因，</span></span><br><span class="line"><span class="comment">// - 二次赋值不被允许</span></span><br><span class="line"><span class="comment">// - 没被初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量遮蔽"><a class="markdownIt-Anchor" href="#变量遮蔽"></a> 变量遮蔽</h3><p><code>rust</code> 允许在用一个代码块中同时声明同样名字的变量。如果这样做，后声明的变量会将前面声明的变量<strong>遮蔽</strong>（Shadowing）起来。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x is &#123;&#125;&quot;</span>,x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x is &#123;&#125;&quot;</span>,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以转换变量是否可改；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反过来也可以。</p><h3 id="类型推导"><a class="markdownIt-Anchor" href="#类型推导"></a> 类型推导</h3><p>和 <code>TS</code> 类似。RUST 的类型推导功能是很强大的。可以通过上下文信息进行推导。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">elem</span> = <span class="number">5u8</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>= <span class="built_in">vec!</span>[];</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(elem);</span><br><span class="line"><span class="comment">// 到后面调用了 push</span></span><br><span class="line"><span class="comment">// 根据 elem 确定 v 的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以只写一部分，用 <code>_</code> 来代替。</p><h3 id="类型别名"><a class="markdownIt-Anchor" href="#类型别名"></a> 类型别名</h3><p><code>type</code> 关键字</p><h3 id="整数类型"><a class="markdownIt-Anchor" href="#整数类型"></a> 整数类型</h3><table><thead><tr><th>整数类型</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8 bits</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16 bits</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32 bits</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64 bits</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128 bits</td><td><code>i128</code></td><td><code>u128</code></td></tr></tbody></table><p>范围问题和计算机组成原理一致。<br />浮点类型也是如此。</p><h3 id="指针类型"><a class="markdownIt-Anchor" href="#指针类型"></a> 指针类型</h3><p><code>Rust</code> 中有指针类型，而且不止一种。</p><table><thead><tr><th>类型名</th><th>简介</th></tr></thead><tbody><tr><td><code>BOX&lt;T&gt;</code></td><td>指向类型 T 的具有所有权的指针、有权释放内存</td></tr><tr><td><code>&amp;T</code></td><td>指向类型 T 的借用指针，也称为引用，无权释放内存，无权写数据</td></tr><tr><td><code>&amp;mut T</code></td><td>指向类型 T 的 <code>mut</code> 型借用指针，无权释放内存，有权写数据</td></tr><tr><td><code>*const T</code></td><td>指向类型 T 的只读裸指针，没有生命周期信息，无权写数据</td></tr><tr><td><code>*mut T</code></td><td>指向类型 T 的可读写裸指针，没有生命周期信息，有权写数据</td></tr></tbody></table><p>除了上述指针，还有一种智能指针。</p><table><thead><tr><th>类型名</th><th>简介</th></tr></thead><tbody><tr><td><code>Rc&lt;T&gt;</code></td><td>指向类型 T 的引用计数指针，共享所有权，线程不安全</td></tr><tr><td><code>Arc&lt;T&gt;</code></td><td>指向类型 T 的原子性引用技术指针，共享所有权，线程安全</td></tr><tr><td><code>Cow&lt;'a,T&gt;</code></td><td><code>Clone-on-write</code> ，写时复制指针，可能是借用指针，也可能是具有所有权的指针</td></tr></tbody></table><blockquote><p><a class="link"   href="https://www.zhihu.com/search?q=%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A14918675%7D" >智能指针<i class="fas fa-external-link-alt"></i></a>和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。</p></blockquote><p>就是为了避免具有引用的对象，莫名其妙被销毁，常用于线程之间共享变量。<br />智能在自动计数引用，普通的离开了就销毁了。</p><h3 id="复合类型"><a class="markdownIt-Anchor" href="#复合类型"></a> 复合类型</h3><h3 id="tuple"><a class="markdownIt-Anchor" href="#tuple"></a> tuple</h3><h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2><p>谈到递归调用，许多读者都会自然联想到&quot;尾递归优化&quot;这个概念。</p><p>可惜的是，当前版本的 Rust 暂时还不支持尾递归优化，因此如果递归调<br />用层次太多的话，是有可能撑爆栈空间的。不过这个问题已经在设计讨<br />论之中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;forma</summary>
      
    
    
    
    <category term="技术学习" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="编程语言" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="rust" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/rust/"/>
    
    
    <category term="关键字" scheme="http://example.com/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>游戏框架</title>
    <link href="http://example.com/posts/V7YWGR.html"/>
    <id>http://example.com/posts/V7YWGR.html</id>
    <published>2024-12-31T14:45:02.394Z</published>
    <updated>2024-12-31T14:45:02.394Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="玩家设备电脑-游戏机等-开始游戏"><a class="markdownIt-Anchor" href="#玩家设备电脑-游戏机等-开始游戏"></a> 玩家设备（电脑、游戏机等）-开始游戏</h2><h2 id="游戏实例-进入游戏关卡默认地图"><a class="markdownIt-Anchor" href="#游戏实例-进入游戏关卡默认地图"></a> 游戏实例-进入游戏关卡（默认地图）</h2><p>这是整个游戏的进程，也就是游戏运行的上下文，一般做一些初始化的功能, 在以下可以选择关联游戏实例。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/media/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/IMG-%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6-20231112092149290.png"                      alt=""                 ></p><h3 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h3><p>整个游戏的初始，整个游戏销毁的时候，整个游戏出现错误的时候，</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/media/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/IMG-%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6-20231112092103303.png"                      alt=""                 ></p><h2 id="进入关卡"><a class="markdownIt-Anchor" href="#进入关卡"></a> 进入关卡</h2><p>加载地图</p><h2 id="找到游戏模式-加载游戏信息"><a class="markdownIt-Anchor" href="#找到游戏模式-加载游戏信息"></a> 找到游戏模式 -加载游戏信息</h2><p>游戏模式一般定义游戏规则<br />若没有设置游戏模式，会进入默认游戏模式</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/media/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/IMG-%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6-20231112092551244.png"                      alt="游戏模式设置"                 ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/media/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/IMG-%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6-20231112092705191.png"                      alt=""                 ></p><p>每次打开新的地图，会<strong>重新</strong>加载对应的游戏模式。在联机的情况下，只有主机（服务器才有游戏模式），其他玩家可以从游戏模式中获取其他的游戏状态，用于<strong>复现状态</strong></p><h2 id="初始化玩家控制器"><a class="markdownIt-Anchor" href="#初始化玩家控制器"></a> 初始化玩家控制器</h2><p>玩家设备都是与玩家控制器关联的<br />在游戏模式中设置玩家控制器相关的信息<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="/media/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/IMG-%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6-20231112093344505.png"                      alt=""                 > <img                       lazyload                     src="/images/loading.svg"                     data-src="/media/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/IMG-%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6-20231112093603930.png"                      alt=""                 ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/IMG-%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6-20231112093610859.png"                      alt=""                 ></p><h2 id="蓝图基础"><a class="markdownIt-Anchor" href="#蓝图基础"></a> 蓝图基础</h2><p>通过使用蓝图，设计人员几乎可以创作任何游戏元素的原型，以及实现或修改这些元素。</p><ul><li>Games（游戏）创建游戏规则，调整游戏条件等。</li><li>Players （玩家）使用不同的网格物体、材质或角色自定义来创建变种</li><li>Cameras （相机）创建新相机视角的原型或者在游戏运行过程中动态地改变相机。</li><li>Input（输入）修改玩家操作，或允许玩家向道具传入输入</li><li>Items （道具）武器、法术、掉落物、触发器等。</li><li>Environments （环境）创建随机的装置或者程序化地生成道具。</li></ul><p><strong>蓝图类型</strong></p><p><strong>关卡蓝图（Level Blueprint）</strong><br />关卡蓝图是一种特殊类型的蓝图，是作用于整个关卡的全局事件图表。关卡事件或者关卡中的 Actor 的特定实例，用于激活以函数调用或者流程控制操作的形式呈现的动作序列。</p><p><strong>类蓝图 （Blueprint Class）</strong><br />类蓝图是一种允许内容创建者轻松地基于现有游戏性类添加功能的资源。它是在编辑器中可视化地创建的，不需要书写代码，会被作为类保存在包中。</p><p><strong>仅包含数据的蓝图（Data-Only Blueprint）</strong></p><p>仅包含数据的蓝图是指仅包含代码（以节点图表的形式）、变量及从父类继承的组件的类的蓝图。仅包含数据的蓝图允许你调整及修改继承的属性，但是不能添加新元素。从本质上讲，这些蓝图是原型的替代物，设计人员可以使用它们来调整属性或者设置具有变种的项目。可以通过添加代码、变量或者组件来将它转换成完整的类蓝图。</p><p><strong>蓝图接口（Blueprint Interface）</strong></p><p>蓝图接口是一个函数或多个函数的集合，它相当于C++中的一个纯虚基类，仅有函数名称，没有实现，该接口可以添加到其它蓝图中。使用具有该接口的蓝图，都一定会具备这些函数。在每个添加了接口的蓝图中，都可以提供接口的这些函数功能。从本质上讲这各一般编程中的接口概念一样，允许通过一个公共接口来共享及访问多种不同类型的对象。简单地讲，蓝图接口允许不同的类蓝图间彼此共享及发送数据。</p><p>蓝图接口的创建和其他类似，可以通过编辑器中的内容创建器进行创建，但它们有一些局限性，因为它们<strong>不能</strong>：</p><ul><li>添加新变量</li><li>编辑图表</li><li>添加组件</li></ul><p><strong>蓝图宏库（Blueprint Macro Library）</strong></p><p>蓝图宏库是一个存放了一组宏的容器，或者是可以像节点那样放置到其他蓝图中的自包含图表。这些蓝图宏库非常节约时间，因为它们存放了常用的节点序列、及针对执行和数据变换的输入和输出。</p><p>宏会在所有引用它们的图表间共享，但是如果它们在编译过程中是合并的节点，那么它们会自动地展开为图表。这意味着蓝图宏库不需要进行编译，但是对宏所做的修改，仅当重新编译了包含引用该图表的蓝图时，这些修改才会反应在图表中。</p><h3 id="蓝图通信"><a class="markdownIt-Anchor" href="#蓝图通信"></a> 蓝图通信</h3><p><a class="link"   href="https://www.cnblogs.com/songiveideas/p/learnmore2.html" >UE4学习心得：蓝图间信息通信的几种方法 - 白露期霜 - 博客园<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>蓝图通信可以理解为不同蓝图间的信息传递和共享</p></blockquote><ul><li><p>直接蓝图<br />直接引用节点，选中场景中的 Actor 或者蓝图，然后进行引用（或者使用变量，效果一样），只有需要通信的类都在关卡中有实例时才可以使用，注意是实例对象，而非类</p></li><li><p>首先在 Editor 中创建 2 个 Actor 蓝图类，分别命名为 TargetActor 和 ControllerActor，双击打开 TargetActor 编辑器，将组件窗口中的 DefaultSceneRoot 替换成 Cube，并设置成 Movable，编译后保存退出，然后打开 ControllerActor，将组件窗口中的 DefaultSceneRoot 替换成 Sphere，新建变量 Actor，类型为 Actor 引用，将其设为公共变量。返回关卡编辑器中，将 2 个 Actor 拖放进场景中，点击 ControllerActor，在 Details 面板中可以看到 Default 选项将 Actor 设为 TargetActor 或者点击右侧的针状标记，然后选中场景中的 TargetActor，返回 ControllerActor 编辑器中，添加一个 Event Tick 事件，运行关卡后可以看到 TargetActor 在不断地上升，说明在 ControllerActor 蓝图类中的逻辑成功地运行了，两个蓝图类之间完成了信息交互。</p></li><li><p>蓝图投射<br />通过类的投掷（Cast）结合<strong>GetAllActorOfClass</strong>这个蓝图节点，就可以完成类似于直接蓝图的效果进行通讯。</p></li><li><p>事件调度器<br />创建事件节点，调用事件，完成绑定以及调用</p></li><li><p>蓝图接口<br />这种实现方式相对有些复杂，但是某种程度上最不受限制</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;玩家设备电</summary>
      
    
    
    
    <category term="游戏开发" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="UE学习" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/UE%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 Git 对UE源码进行版本控制</title>
    <link href="http://example.com/posts/1H8HWT2.html"/>
    <id>http://example.com/posts/1H8HWT2.html</id>
    <published>2024-12-31T14:45:02.377Z</published>
    <updated>2024-12-31T14:45:02.378Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="为什么-git-而非-svn"><a class="markdownIt-Anchor" href="#为什么-git-而非-svn"></a> 为什么 Git 而非 SVN</h2><h3 id="git-和-svn-命令"><a class="markdownIt-Anchor" href="#git-和-svn-命令"></a> git 和 svn 命令</h3><blockquote><p>基本命令</p></blockquote><table><thead><tr><th>作用</th><th>git</th><th>svn</th></tr></thead><tbody><tr><td>版本库初始化</td><td>git init</td><td>svn create</td></tr><tr><td>clone</td><td>git clone</td><td>svn co（checkout）</td></tr><tr><td>add</td><td>git add （.除去.gitignore，*所有的文件）</td><td>svn add</td></tr><tr><td>commit</td><td>git commit</td><td>svn commit</td></tr><tr><td>pull</td><td>git pull</td><td>svn update</td></tr><tr><td>push</td><td>git push</td><td>-</td></tr><tr><td>查看工作状态</td><td>git status</td><td>svn status</td></tr><tr><td>创建分支</td><td>git branch &lt;分支名&gt;</td><td>svn cp &lt;分支名&gt;</td></tr><tr><td>删除分支</td><td>git branch -d &lt;分支名&gt;</td><td>svn rm &lt;分支名&gt;</td></tr><tr><td>分支合并</td><td>git merge &lt;分支名&gt;</td><td>svn merge &lt;分支名&gt;</td></tr><tr><td>工作区差异</td><td>git differ （-cached / head）</td><td>svn diff</td></tr><tr><td>更新至历史版本</td><td>git checkout <commit></td><td>svn update -r <rev></td></tr><tr><td>切换 tag</td><td>git checkout <tag></td><td>svn switch <tag></td></tr><tr><td>切换分支</td><td>git checkout branch</td><td>svn switch branch</td></tr><tr><td>还原文件</td><td>git checkout - path</td><td>svn revert path</td></tr><tr><td>删除文件</td><td>git rm path</td><td>svn rm path</td></tr><tr><td>移动文件</td><td>git mv path</td><td>git mv path</td></tr><tr><td>清除未追踪文件</td><td>git clean</td><td>svn status sed -e</td></tr></tbody></table><h3 id="存贮区别"><a class="markdownIt-Anchor" href="#存贮区别"></a> 存贮区别</h3><ol><li>git 是分布式的，有本地和远程两个版本库，SVN 是集中式，只有一个远程版本库；</li><li>git 的内容是按元数据方式存贮，所有控制文件在.git 中，svn 是按文件处理，所有资源控制文件在.svn 中；</li><li>svn 的分支是一个目录，git 不是；</li><li>git 没有一个全局的版本号，svn 有；</li><li>git 内容存贮是使用 SHA-1 哈希算法，能确保代码完整性;</li><li>git 有工作区，暂存区，远程仓库，git add 将代码提交到暂存区， commit 提交到本地版本库，push 推送到远程版本库。svn 是 add 提交到暂存，commit 是提交到远程版本库。</li></ol><p>所以单个文件为单位的适合使用 SVN 管理</p><h3 id="git-lfs"><a class="markdownIt-Anchor" href="#git-lfs"></a> Git LFS</h3><p>由于 UE 又经常包含大文件，而对于包涵大文件（尤其是经常被修改的大文件）的项目，初始克隆需要大量时间，因为客户端会下载每个文件的每个版本。<strong>Git LFS</strong>（Large File Storage）是由 Atlassian, GitHub 以及其他开源贡献者开发的 Git 扩展，它通过延迟地（lazily）下载大文件的相关版本来减少大文件在仓库中的影响，具体来说，大文件是在 checkout 的过程中下载的，而不是 clone 或 fetch 过程中下载的。Git LFS 通过将仓库中的大文件替换为微小的<em>指针（pointer）</em>  文件来做到这一点。</p><p>当推送新的提交到服务器时，新推送的提交引用的所有 Git LFS 文件都会从本地 Git LFS 缓存传输到绑定到 Git 仓库的远程 Git LFS 存储（<strong>即 LFS 文件内容会直接从本地 Git LFS 缓存传输到远程 Git LFS 存储服务器</strong>）。</p><h4 id="加快克隆速度"><a class="markdownIt-Anchor" href="#加快克隆速度"></a> 加快克隆速度</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs <span class="built_in">clone</span> &lt;remote-url&gt;</span><br></pre></td></tr></table></figure><h3 id="使用-git-lfs-跟踪文件"><a class="markdownIt-Anchor" href="#使用-git-lfs-跟踪文件"></a> 使用 Git LFS 跟踪文件</h3><p>当向仓库中添加新的大文件类型时，需要通过使用 git lfs track 命令指定一个模式来告诉 Git LFS 对其进行跟踪：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git lfs track &quot;*.ogg&quot;</span><br><span class="line">Tracking *.ogg</span><br></pre></td></tr></table></figure><h2 id="ue中配置git"><a class="markdownIt-Anchor" href="#ue中配置git"></a> <code>ue</code>中配置<code>git</code></h2><p>打开<code>UE</code>后，在<code>UE</code>的顶部菜单中找到<code>Source Control</code></p><p>!<a class="backlink">使用 Git 对UE源码进行版本控制-20240401175934373.png</a></p><p><code>UE</code>提供的列表中选中<code>Git</code>后，出现下图的窗口<br />!<a class="backlink">使用 Git 对UE源码进行版本控制-20240401180024295.png</a></p><p>点击<code>Accept Settings</code>即可!</p><blockquote><p>需要注意的是，这里还仅仅只是<code>commit</code>到本地，还需要在<code>git bash</code>中<code>git push</code></p></blockquote><h2 id="在-ue-中合并蓝图代码"><a class="markdownIt-Anchor" href="#在-ue-中合并蓝图代码"></a> 在 UE 中合并蓝图代码</h2><p>可以通过  <code>diff</code>  来检测我们此次相较于上次提交的版本做了哪些修改：在该蓝图类上右键  <code>Source Control</code>-&gt;<code>Diff Against Depot</code>，会弹出<code>diff</code>  窗口。我们可以看到我们在该蓝图类中修改了哪些东西。</p><p>!<a class="backlink">使用 Git 对UE源码进行版本控制-20240401180537802.png</a></p><p>!<a class="backlink">使用 Git 对UE源码进行版本控制-20240401180435332.png</a></p><p>比如创建了新的函数，提交内容。</p><p>!<a class="backlink">使用 Git 对UE源码进行版本控制-20240401180645797.png</a><br />!<a class="backlink">使用 Git 对UE源码进行版本控制-20240401180735856.png</a><br />在蓝图类上右键 -&gt;<code>Source Control</code>下共有以下几个选项：<code>Check In</code>/<code>Refresh</code>/<code>History</code>/<code>Diff Against Depot</code>/<code>Revert</code>，其中  <code>Check In</code>  和<code>Diff Against Depot</code>的用途上面已经说过了。</p><p><strong>Check In</strong>提交当前文件。</p><p><strong>Refresh</strong>刷新当前文件 (蓝图类) 状态(status)。</p><p><strong>History</strong>查看提交 (Check In) 的历史，也可以提供当前未提交改动与某一提交版本的区别。</p><p><strong>Diff Against Depot</strong>查看当前未提交 (Check In) 改动与上次提交版本的区别。</p><p><strong>Revert</strong>丢弃当前未提交 (Check In) 改动 (就是回滚到上一次 Check In 时的状态)。注意：Revert 之后需要重启引擎才会生效，这应该是 UE(4.12.5) 的一个 BUG。<strong>Revert</strong>的效果等同于直接在 Git Bash 下执行<code>git checkout -- $&#123;filename&#125;</code>。<br />!<a class="backlink">使用 Git 对UE源码进行版本控制-20240401181002380.png</a></p><blockquote><p>UE 中集成的 Source Control::Git 是不能够直接在虚幻编辑器中直接回滚到某一提交版本的，总的来说可供操作的功能还比较少 (蓝图的节点比对还是很爽的)，但是可以结合<code>Git Bash</code>  来使用 Git 的其他操作(版本回退 / 分支管理 / 远程推送等等)。</p></blockquote><blockquote><p>需要注意的是，使用  <code>Git Bash</code>  来进行版本回退的话一定要关闭虚幻编辑器，因为回退需要对文件进行改动，而虚幻编辑器正在占用 (打开) 该文件 (蓝图类)，而对未占用(打开) 的文件 (蓝图类) 进行版本回退也需要重启虚幻编辑器才可以(不重启不会看到回退效果)。</p></blockquote><p>使用 Git 来推送 (push) 和拉取 (pull) 远程分支的话需要在 Git Bash 中执行。同样也需要关闭虚幻编辑器。注意编辑  <code>.gitignore</code>  来忽略不必要的文件来节省 push/pull 时间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;为什么-g</summary>
      
    
    
    
    <category term="游戏开发" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="UE学习" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/UE%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>【UE 推荐教程集锦】</title>
    <link href="http://example.com/posts/3AX6KXX.html"/>
    <id>http://example.com/posts/3AX6KXX.html</id>
    <published>2024-12-31T14:45:02.376Z</published>
    <updated>2024-12-31T14:45:02.377Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2><h3 id="视频类"><a class="markdownIt-Anchor" href="#视频类"></a> 视频类</h3><ul><li><a class="link"   href="https://www.bilibili.com/video/BV164411Y732?p=1&amp;vd_source=7f97f243f348f7f28f03f399b2063fe6" >【虚幻 4】UE4 初学者系列教程合集<i class="fas fa-external-link-alt"></i></a></li></ul><ol><li>P9~P11: 视图编辑部分基础，学到这一部分，虽然对于每一个东西可能并不是很了解，但是这儿是前端思考方式和 UE 思考方式的分水岭，因为作为 Javascriptor,我们更加习惯使用各种二维式的布局，很少去手动定位，但是 UE 毕竟是号称给美术家们的工具。</li></ol><ul><li><p><a class="link"   href="https://www.bilibili.com/video/BV1QP4y1U7H3/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c7d03b0109b9075369185655605ec392" >【UE 必看】【UE5 节点大全】<i class="fas fa-external-link-alt"></i></a><br />确实是必看，这玩意用来做复习，挺不错，</p></li><li><p><a class="link"   href="https://www.bilibili.com/video/BV19T4y1P7RS/?spm_id_from=333.999.0.0&amp;vd_source=7f97f243f348f7f28f03f399b2063fe6" >UE4 智慧城市可视化实例教程<i class="fas fa-external-link-alt"></i></a></p></li></ul><ol><li><p>p11~p13 部分：通过这一部分，可以学到基本如何用 UNG，对于前端 er 来说，值得注意的是 UMG 是相对更加熟悉的，但是又不会太熟悉，熟悉的是那些布局方式，和所谓的锚点（transition-origin)，但是不熟悉的是，这个在有过对浏览器渲染有一定理解之后，思考起来会更加得心应手（主要是部分 HUD，可以对照思考 Canvas)。</p></li><li><p>这个 UP 主的案例，还算是比较有设计感的，是不是没有想法的时候就来看一下。</p></li></ol><ul><li><a class="link"   href="https://www.bilibili.com/video/BV1op4y1V71r?p=1&amp;vd_source=7f97f243f348f7f28f03f399b2063fe6" >【数字孪生-教程】UE5+Cesium 智慧城市&amp;园区全流程开发-数据篇<i class="fas fa-external-link-alt"></i></a></li></ul><ol><li>Mark 住，这儿用到的时候再看吧，大概是对城市一些地形场景中会用到，（本人也只是粗看勒一下目录，大概知道有哪些功能。</li></ol><ul><li><a class="link"   href="https://www.bilibili.com/video/BV1dz4y1A7G3?p=6&amp;vd_source=c7d03b0109b9075369185655605ec392" >虚幻引擎倾囊相授计划：AI 行为树系统教程<i class="fas fa-external-link-alt"></i></a><br />(●’◡’●)最近也还在看。</li></ul><h3 id="文档类"><a class="markdownIt-Anchor" href="#文档类"></a> 文档类</h3><p>视频看起来始终没有书籍看着快，因为文档或者书本，总是一些列总结性的句子。比起会看视频学习，查文档总是更加高效的办法，当然更加简单的就是(GPT)了，顺便推荐一个网站 <a class="link"   href="https://poe.com" >poe<i class="fas fa-external-link-alt"></i></a>。</p><ul><li><a class="link"   href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/unreal-engine-5-3-documentation" >官方文档<i class="fas fa-external-link-alt"></i></a><br />官方文档一直被吐槽,不是没有原因的,内容杂乱,很难看懂,作为一枚菜鸡,把这个文档翻了不下 10 次之后,总算知道这个文档的正确用法了,这个文档最多的是例子,对于很多流程性质的和概念性质的讲的是是而非,要想弄懂究竟这篇文档讲什么,就需要搞懂他主要有用的模块和可以作为字典来查的模块.</li></ul><ol><li>内容管理模块：也就是下面部分<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="http://cloud.datamatrixai.com:30137/uploads/ue-web/images/m_3f2e7d3d7356afe75b834c22e89accde_r.png"                      alt=""                 ><br />然后就可以知道如何开启一个新项目了，当然也要跳着看，比如<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="http://cloud.datamatrixai.com:30137/uploads/ue-web/images/m_d60c920762bf5f235170ae3692de1991_r.png"                      alt=""                 ><br />(╯°□°）╯︵ ┻━┻ 这一部分放前面 Duck 不必啊，当作字典来查就好了。</li><li>基本概念模块<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="http://cloud.datamatrixai.com:30137/uploads/ue-web/images/m_65acd3b33f307b77900e7e39466be1d6_r.png"                      alt=""                 ><br />相对而言这一部分，最好跳过先，不然会迷糊的，但是这个作为一个探寻的地图入口还是靠谱的。</li><li>References<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="http://cloud.datamatrixai.com:30137/uploads/ue-web/images/m_85308498c62f0f59670e7b3e542f175e_r.png"                      alt=""                 ><br />个人感觉官方文档的案例写的都挺虎头虎脑的，看起来很复杂，至少菜鸡如我的中间的案例，如看，这些参看文档是他最后的宝藏了，至于如何看懂这个文档，这个就得分模块了，我也只能是现查现用，具体模块也还没分出来。</li></ol><ul><li><p><a class="link"   href="https://github.com/insthync/awesome-unreal" >Awesome 系列<i class="fas fa-external-link-alt"></i></a><br />喜闻乐见的 Awesome 系列，这里有很多工具，平常的时候看到个名字有个印象就可以了。</p></li><li><p><a class="link"   href="https://www.tdpress.com/cms/book/851" >Unreal Engine 4 学习总动员——C++编程<i class="fas fa-external-link-alt"></i></a><br />微信读书上有，配合大象无形效果更好，知道简单的 API 和，就已经可以理解和运行 UE 中的 C++了</p></li></ul><h2 id="进阶"><a class="markdownIt-Anchor" href="#进阶"></a> 进阶</h2><h3 id="c"><a class="markdownIt-Anchor" href="#c"></a> C++</h3><ul><li><a class="link"   href="https://www.bilibili.com/video/BV1jj42197DL/" >基础理解<i class="fas fa-external-link-alt"></i></a></li></ul><ol><li>这个视频的作用，大概就是和前端去理解了事件循环和代码之间的作用，看了这一部分，大概可以理解 UE 中大概是如何开始运行的。</li></ol><ul><li><a class="link"   href="https://github.com/MrRobinOfficial/Guide-UnrealEngine" >Guide-UnrealEngine<i class="fas fa-external-link-alt"></i></a></li></ul><ol><li>必须 Mark 住，简单过一圈，能对很多有的没得对象有个记忆就很不错了，但罪常看的还是前面几个 CheatSheet，名字对应节点（准确来说蓝图的方法名来源于 C<ins>的方法名，所以用的时候，从蓝图到 C</ins> 的思考方式就是你用到的节点名，当然更复杂的就是 C++ 基础了。</li></ol><ul><li><a class="link"   href="https://b23.tv/WOibCFp" >【（中字）UE5 虚幻引擎 5 C++：创建自定义编辑器工具-哔哩哔哩】<i class="fas fa-external-link-alt"></i></a><br />(●’◡’●)最近也还在看。</li></ul><h2 id="个人在看ing书单"><a class="markdownIt-Anchor" href="#个人在看ing书单"></a> 个人在看(ing)书单</h2><ul><li><a class="link"   href="https://github.com/couriourc/couriourc.github.io/blob/source/_posts/%E4%B9%A6%E5%8D%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB/%E5%A4%A7%E8%B1%A1%E6%97%A0%E5%BD%A2%EF%BC%9A%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%B5%85%E6%9E%90.pdf" > 大象无形 <i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/couriourc/couriourc.github.io/blob/source/_posts/%E4%B9%A6%E5%8D%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB/Unreal%20Engine%204%20%E6%9D%90%E8%B4%A8%E5%AE%8C%E5%85%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B.pdf" >Unreal Engine 4 材质完全学习教程<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/couriourc/couriourc.github.io/blob/source/_posts/%E4%B9%A6%E5%8D%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB/Unreal%20Engine%204%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%EF%BC%88%E5%BC%82%E6%AD%A5%E5%9B%BE%E4%B9%A6%EF%BC%89.pdf" >Unreal Engine 4 游戏开发入门经典<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>整体而言，UE 这东西毕竟是工具，既然是使用工具，那么知道在哪儿用比知道他怎么产生会更加快一些，但是如果只是知道工具怎么用，不是不可以，但是很显然，将知识的原理拍平，会发现很多都是通用的。当然只是会用的话，只需要知道下面步骤就行：</p><ol><li>知道流水线（流程）【(●’◡’●)个人也还在梳理】</li><li>调用 API，发现很卡，然后开始优化</li><li>知道如何构建，打包。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;基础&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="游戏开发" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="UE学习" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/UE%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>UE 幸福感提升秘籍</title>
    <link href="http://example.com/posts/3EPG1Z1.html"/>
    <id>http://example.com/posts/3EPG1Z1.html</id>
    <published>2024-12-31T14:45:02.375Z</published>
    <updated>2024-12-31T14:45:02.376Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="视窗操作篇"><a class="markdownIt-Anchor" href="#视窗操作篇"></a> 视窗操作篇</h2><h3 id="actor-上的视窗操作"><a class="markdownIt-Anchor" href="#actor-上的视窗操作"></a> Actor 上的视窗操作</h3><ul><li><p>对屏幕外物体进行位移旋转缩放<br />按住键盘上的 Ctrl 键不放，同时用鼠标 左键 或者 右键 或者 左键+右键，来进行远距离的位移旋转缩放。</p></li><li><p>循环变换（空格）和变换（W/E/R）</p></li><li><p>世界场景/局部场景变换（`Ctrl+``）</p></li><li><p>物体吸附到模型顶点<br />在移动模式下，按住键盘上的 V 键不放，加鼠标拖动物体移动轴心，可以吸附到附近物体的顶点上。</p></li><li><p>屏幕编队<br />用快捷键 Ctrl + 数字（0-9），可以对当前相机状态编队。 再用数字（0- 9）返回之前相机编队的状态。</p></li><li><p>落到正下方物体<br />大部分时候 End ,Alt + End 会按照轴心点吸附,而吸附实际上算的是模型的 bounds ； <code>Show&gt; Advanced &gt;Bounds</code> 可以显示模型的<code>Bounds</code>。<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="/media/m_f9f0af9ce90911aa70fbf5c0cfc6f75b_r.png"                      alt=""                 ></p></li><li><p>显示与隐藏<br />相关的常用操作有这么四个<br />hide selected 隐藏选中 Actor （<code>H</code>）<br />show selected 显示选中 Actor (<code>Shift+H</code>)<br />show all actors 显示所有场景中的 Actor (<code>Ctrl+H</code>)<br />show only selected 只显示当前选中的 Actor (，一般未设置，<code>Shift+I</code>)</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_5a81b319904d307fe9d27f86e17b42ae_r.png"                      alt=""                 ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_299acf72d23c24fc138c324f16eb819b_r.png"                      alt=""                 ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_2505de50d4e29620a0f42e4a6c02e0e4_r.png"                      alt=""                 ></p><ul><li>设置枢轴位置（鼠标右键 -&gt;“枢轴（pivot）”-&gt;&quot;在此设置枢轴偏移（Set pivot offset here）<br />也可以在点击的地方（Alt + 鼠标中键），或通过鼠标中键拖动，把它放在我们需要的地方。<blockquote><p>附加诀窍：可以更改变换吸附的默认值，<code>（Editor Preferences）”&gt;“（Level Editor）”&gt;“（Viewport）”&gt;“（Grid Snapping）</code>。<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_28b215b7b10aa099dcbd56fe743319b1_r.png"                      alt=""                 ></p></blockquote></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_b1d936e69c121d424fc97dcdeaa63ed7_r.png"                      alt=""                 ></p><p>附加 Actor 可能在多种情况下都很有用，你也许可以自己想到一些用途，不过前提是你必须知道有这种操作。只要记住两个 Object 的移动性设置必须相同就好（静态/可移动）。</p><ul><li><p>显示轮廓（G）<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_185aa61331db6c1a049284a49f5e1de8_r.png"                      alt=""                 ></p></li><li><p>视图模式，这些模式在各种情况下都很方便，所以应该了解它们的存在和访问它们的方法。<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_71813e0d8a1b4f97d17bf9a433f1bcd6_r.png"                      alt=""                 ></p></li><li><p>显示导航（P）<br />查看关卡中是否有任何 Object 可能挡住 AI 或玩家的去路。<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_9fe09d5068ee694c8ac0fffc35e81ff0_r.png"                      alt=""                 ><br />绿色表示可通行。</p></li><li><p>透视/侧视/顶视/前视图（Alt + G/K/H/J）<br />熟悉 vim 快捷键的知道，h,j,k,l 的含义。</p></li><li><p>使 Object 吸附到视图和视图吸附到 Object<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_68e83b9cbc5aaf463239d7da934f6ada_r.png"                      alt=""                 ><br />这个诀窍在我想要把摄像机准确放到我所观察的位置时最有用。将选定的 Object 吸附到摄像机，然后不仅更改其位置，还更改旋转，这样一来上述摄像机就会准确地指向你在视口中所观察的位置。<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_31433834dbba571de410e5fbeac24371_r.png"                      alt=""                 ></p></li><li><p>选项卡导航（Ctrl + Tab）<br />算是双屏福利吧 ~{：-}</p></li><li><p>编组和取消编组（Ctrl +G/Shift + G）</p></li><li><p>选择 Object 的关卡——设置为当前关卡（M）</p></li></ul><h2 id="资源操作篇"><a class="markdownIt-Anchor" href="#资源操作篇"></a> 资源操作篇</h2><ul><li><p>在内容浏览器中查找资源（Ctrl + B）<br />一个技巧,<code>Ctrl+B</code>然后使用资源的指定键，丝滑选类。<br />选中 Reference Viewer 中的资产，可以再次使用 Ctrl+B 查看选中资产的存放位置；也可以使用 Ctrl + E 打开该资产的编辑面板;也可以双击某个节点，查看该节点的引用关系。</p><blockquote><p>只比双击快一点点，鼠标寿命堪忧 ~{：)}</p></blockquote></li><li><p>显示引用（Alt + Shift + R）</p><blockquote><p>只比右键快一点点。</p></blockquote></li><li><p>ContentBrowser 骚操作<br />在 Content Browser 的搜索栏，输入 空格， 可以查看该文件夹下的所有文件。<br />在当前 ContentBrowser 面板锁定的情况下，使用快捷键 Ctrl + B ，可以快速调出新的 ContentBrowser 面板。<br />当需要多个 ContentBrowser 面板去同时操作多个资产的时候，不用在 UI 里慢慢点开新的 ContentBrowser 面板了。<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_5f089a1ae2e6aa40a805946930b692d8_r.png"                      alt=""                 ></p></li><li><p>快速调用资产<br />Ctrl + P Open Asset,类似 vscode 中的 ctrl+e 的作用，用来做资源快速查找的。输入快捷键后，会调入这样一个小面板，可以在 搜索栏中按名称查找到自己想要的资产，可以配合左侧的 filters 过滤想要的资产类型。相当于一个快速简洁、没有文件夹结构的 content browser， 要求对想要调用的资产名称很熟悉。<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_53ffd4d995ae69ae074ec7727805893f_r.png"                      alt=""                 ><br />在需要调用使用率很高的模型，或者需要赋予一些使用率极高的基础材质或者测试材质时，很方便。（记得找到的资产要拖进场景里，不是双击）</p></li></ul><h2 id="资源管理篇"><a class="markdownIt-Anchor" href="#资源管理篇"></a> 资源管理篇</h2><ul><li><p>Add to Favorites<br />可以将选中文件夹添加到 Favorites，后面就可以快速打开这些常用文件夹。同时， Set Color 可以对文件夹指定颜色，方便用右脑记忆文件夹。比如可以把像素流接口，主关卡文件放在一个集合里面，方便查找。</p></li><li><p>Collections<br />对于 Content Browser 面板中的资产，右键 &gt; Manage Collections 可以将该资产置于某个 Collection 中，方便以后快速调用。Collection 不会移动资产的位置，仅仅将一批资产位置的引用收集在一起。用户可以根据自己的需求，将一些常用、或者相关性较高的细碎文件，放在一个 collection 中方便后续快速调用。</p></li></ul><h2 id="debug-篇"><a class="markdownIt-Anchor" href="#debug-篇"></a> Debug 篇</h2><ul><li><p>展示帧率（show fps）<code>Ctrl + Shift + H</code><br />显示当前运行帧率（非常快速查看帧率的方法，相当于命令行输入 stat fps）,也可以勾选 Editor Preferences&gt; Performance&gt; Show Frame Rate and Memory 选项,让引擎右上角一直显示帧率 和 内存使用情况：</p></li><li><p>profile GPU 显示当前状态 GPU 消耗<code>Ctrl + Shift + ,（逗号）</code></p></li><li><p>进入 Debug Mode<code>(Playing) ;</code><br />在 Play 状态下，按键盘上的 ； （分号键），可以进入。有点类似于 Play 状态下按 F8 的弹出，但是 Debug 模式 是第一人称视角的， 快速检查一下周围环境，比 F8 的弹出使用方便。</p></li><li><p>~ 号键打开控制台<br />在什么都不输入的情况下，使用键盘上的 箭头 ↑ 键，可以看到并且选择之前已经输入过的控制台指令，反复开关某些指令的时候，非常实用</p></li></ul><h2 id="常用控制台命令"><a class="markdownIt-Anchor" href="#常用控制台命令"></a> 常用控制台命令</h2><ul><li><p>stat fps<br />显示帧率</p></li><li><p>stat unit<br />显示包括 Draw Call ，游戏逻辑等各种项的消耗</p></li><li><p>stat rhi<br />显示各种 GPU 上的消耗细则</p></li><li><p>r.Tonemapper.Sharpen<br />锐化，后面跟数字表示锐化强度。比如：r.Tonemapper.Sharpen 3</p></li><li><p>r.Streaming.PoolSize<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_a8fa5aa0861c25518b87ef6af31da494_r.png"                      alt=""                 ><br />当你的场景稍微复杂一些的时候，默认纹理流送池就会被挤爆，导致部分贴图加载成很小的 lod，画面会糊。<br />默认有 1G 显存分配给了纹理流送池，不够用的时候可以手动调大。<br />比如，r.Streaming.PoolSize 4096，就可以分配 4G 显存给纹理流送池。 这个参数吧，量力而行就可以了。<br />当然，懒人最爱用的是 r.Streaming.PoolSize 0，可以设置纹理流送池 无上限。<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_b780047f183a8569f5f545f3e14d5a48_r.png"                      alt=""                 ></p></li><li><p>slomo<br />游戏运行下的运行速度；很多时候要仔细观察某些视觉效果的时候，可以把整个运行速度调慢。<br />可以使用 slomo 0.1 ，即可将运行速度变成正常的十分之一。 默认参数为 1</p></li><li><p>r.TonemapperFilm<br />开关后处理效果</p></li><li><p>ShowFlag.PostProcessing<br />开关后期盒子的效果</p></li><li><p>HighResShot<br />使用自己指定的尺寸截图， 比如 HighResShot 1920x1080 （注意，数字之间是字母，x 捱科思，不是 乘号）</p></li><li><p>r.AOSpecularOcclusionMode<br />可以让 skylight 产生的 DFAO 产生更准确的高光， 0 为开启，1 为关闭。大多数项目中，粗暴地设置 r.AOSpecularOcclusionMode 0 ，都可以直接获得的 skylight 照明提升</p></li></ul><h2 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> Tips</h2><ul><li><p>蓝图编辑器上编译按钮右边的小箭头上菜单中隐藏着一个小小的菜单。<br />菜单内可以让你选择什么情况下进行保存。里面有三个选项：<br />永不（Never）： 默认设定，手动保存；<br />仅在成功时（On Success Only）： 我喜欢的选项，编译通过后自动保存；<br />总是（Always）： 无论成功与否，只要编译就保存。这样就可以把保存按钮去掉了（:-；</p></li><li><p>显示编辑器实时信息<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_416b4c8ae451b4fcef42c998909f7b7c_r.png"                      alt=""                 ></p><blockquote><p>甚至能看到窗口没聚焦时编辑器的摸鱼现场（FPS=3）</p></blockquote></li><li><p>打包项目后发现内容不一致怎么办？<br />在 项目设置 →（正在）打包 选项卡的 Project 选项集内勾选 完整重编译 选项，即可解决这一问题。（实际上官方也推荐我们这样做）<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_7bfd84b90ab2945cc8fd37f4bd68d6bc_r.png"                      alt=""                 ></p></li><li><p>项目打包后发现内容缺失怎么办？<br />在一些特殊情况下，我们的工程中可能存在某些不会被直接引用的项目内容，但这些内容又恰恰和项目功能息息相关。<br />UE4 在打包的时候往往会将这些看似无关的东西偷偷放走，然后导致成品游戏中的某些功能突然不能用，更有甚者会带来一次愉悦的崩溃……<br />打开 项目设置 选中 项目-正在打包 菜单栏，在 Packaging 分类下的 要打包的非资源额外目录 设置项增加一个数组元素，然后将需要打包的目录填进去即可。</p></li><li><p>解决因为蓝图错误导致的引擎启动失败<br />修改启动配置来禁止蓝图启动重编译。在无法启动编辑器的时候，我们可以选择的方法只有修改配置文件。打开 …/Saved/Config/Windows/Engine.ini （引擎配置）文件并将以下内容填写并保存。</p></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[/Script/Engine.Blueprint]</span></span><br><span class="line"><span class="attr">bRecompileOnLoad</span>=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="section">[/Script/Engine.LevelScriptBlueprint]</span></span><br><span class="line"><span class="attr">bRecompileOnLoad</span>=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="section">[/Script/Engine.AnimBlueprint]</span></span><br><span class="line"><span class="attr">bRecompileOnLoad</span>=<span class="literal">False</span></span><br></pre></td></tr></table></figure><p>造成引擎启动崩溃的原因可能多种多样，主要的原因一般是 中文路径 、某些输入法、先决条件缺失、引擎组件损坏、代码挖坑 逐项针对排查解决即可。</p><ul><li><p>都改过哪里全忘了，细节面板右侧设置按钮，【仅显示已经修改的属性】。<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_42e02483d480562459246c91f05ba16a_r.png"                      alt=""                 ></p></li><li><p>关卡缩略图，【右键关卡，资产操作-捕获缩略图】<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_247ad2795a723a429d5794b4b71d0f15_r.png"                      alt=""                 ></p></li></ul><h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2><blockquote><p>(戴巍：[UE4]偏门实用技巧合集)[<a class="link"   href="https://www.zhihu.com/question/351992572/answer/1559289946" >https://www.zhihu.com/question/351992572/answer/1559289946<i class="fas fa-external-link-alt"></i></a>]<br />(十个&quot;并无卵用&quot;的虚幻 4 使用小技巧)[<a class="link"   href="https://www.sakuraneko.tech/2020/01/30/Ten-Tips-for-Using-Unreal-Engine/" >https://www.sakuraneko.tech/2020/01/30/Ten-Tips-for-Using-Unreal-Engine/<i class="fas fa-external-link-alt"></i></a>]</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;视窗操作篇</summary>
      
    
    
    
    <category term="游戏开发" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="UE学习" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/UE%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>UE C++ 学习</title>
    <link href="http://example.com/posts/3002CSW.html"/>
    <id>http://example.com/posts/3002CSW.html</id>
    <published>2024-12-31T14:45:02.374Z</published>
    <updated>2024-12-31T14:45:02.375Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="ue-c-快速开启指南"><a class="markdownIt-Anchor" href="#ue-c-快速开启指南"></a> UE C++ 快速开启指南</h2><p>作为 UE 的开发一种方式，没有C++，倘若只是使用蓝图开发，固然可以，但是正如来到了巴黎没有去看埃菲尔铁塔，吃夹心饼干，但是没有夹心，总是缺少一点儿核心的。</p><p>我们都知道在计算机中，不论什么开发方式，最终的目的都是去生成机器码，然后才能运行，而UE的开发内容，整体是以C<ins>开启的，你的绘制也会由一种叫做 “Kismet” 转化为 C</ins> Native，从而进一步运行的，所以 UE 的开发从本质来看就是一个C<ins>项目。因此本文会从 C</ins> 执行的角度来对 UE 项目进行一个重新介绍。</p><p>首先本文会简要介绍 C++ 的基本编译流程、简要讲解<strong>预处理、编译、汇编、链接</strong>的过程。</p><h2 id="c基本的编译流程"><a class="markdownIt-Anchor" href="#c基本的编译流程"></a> C++基本的编译流程</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/c++%E7%94%9F%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E7%A8%8B.png"                      alt="c++生成二进制流程"                 ></p><h3 id="预处理阶段"><a class="markdownIt-Anchor" href="#预处理阶段"></a> 预处理阶段</h3><p>如上图所示，C++源码首先会被预处理，在这一步骤中，主要是为了进行一个静态替换，可以理解为编译器帮我们 Replace 了一遍：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A 1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">x a = <span class="number">0</span> ;</span><br><span class="line">std::cout&lt;&lt;A+a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E main.cpp -o main.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line"># 5 &quot;main.cpp&quot;</span><br><span class="line">typedef int x;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main ()&#123;</span><br><span class="line"> x a = 0;</span><br><span class="line"> std::cout&lt;&lt;1 +a;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_1033babb3ac32e8529c55e898877f0ce_r.png"                      alt=""                 ><br />先不看 #include 中展开的 #define ,我们直接看 main 函数部分，可以看到这个时候的 <code>A</code> 已经变成了 <code>1</code>，那这一步我们怎么在 visual studio 进行呢？其实很简单<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_62a130aa1d38e8818a20a3b77d8d4b51_r.png"                      alt=""                 ><br />点击或进入配置数学在此处配置，可以选择是否保留注释。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_59d25d675aae1fb833fca9a861c270ea_r.png"                      alt=""                 ></p><p>经过静态替换之后，也就是说其实之前还是代码源文件处理的文本阶段（这一步在使用Rust开发的时候感慨颇深😒），经过替换后才进入编译器阶段。</p><h3 id="编译器处理阶段"><a class="markdownIt-Anchor" href="#编译器处理阶段"></a> 编译器处理阶段</h3><p>这一部分主要是编译原理的内容了，不过多深入。<br />1.扫描（词法分析），2.语法分析，3.语义分析，4.源代码优化（中间语言生成），5.代码生成，目标代码优化。<br />下列语句可以生成，但是相信我，没啥看的。因为这个时候就是一个二进制了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -s hello.c -o hello.s</span><br></pre></td></tr></table></figure><h3 id="汇编阶段as"><a class="markdownIt-Anchor" href="#汇编阶段as"></a> 汇编阶段（as）</h3><p>主要作用：汇编器是将汇编代码转变成可以执行的指令，生成目标文件。</p><h3 id="链接阶段ld"><a class="markdownIt-Anchor" href="#链接阶段ld"></a> 链接阶段（ld）</h3><p>通过编译器的5个步骤后，我们获得目标代码，但是里面的各个地址还没有确定，空间还没有分配。</p><p>这里面值得我们关注和需要重点理解的是 ld 阶段，浙江有助于我们去理解和使用。链接（Link）其实就是一个&quot;打包&quot;的过程，它将所有二进制形式的目标文件(.o)和系统组件组合成一个可执行文件。C++程序编译的时候其实只识别.cpp文件，每个cpp文件都会分别编译一次，生成一个.o文件。这个时候，链接器除了将目标文件和系统组件组合起来，还需要将编译器生成的多个.o或者.obj文件组合起来，生成最终的可执行文件(Executable file)。</p><h2 id="ue-中开启-c"><a class="markdownIt-Anchor" href="#ue-中开启-c"></a> UE 中开启 C++</h2><p>首先进入项目，然后在 <code>Tools&gt;New C++ Class</code><br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_be157f2bcda5d660e8dfd31c8d64b28e_r.png"                      alt=""                 ><br />接着会弹出对话框，选择希望生成的类型模板。这里为了方便，选中 Actor 类型生成，<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_7fbc71a0f4a265e6b6752f3ea95b601e_r.png"                      alt=""                 ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_4aa4e9f6963fc805255737bd37b9626a_r.png"                      alt=""                 ><br />这有两个值得关注的点，这个之后再描述，本文只是为了简要讲解如何开始一个C<ins>项目，以及看的懂外部C</ins>库引用。创建后，会提示询问是否重新编译，一般选<strong>是</strong><br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_521f70b8671af7fd55be9eb895dddb0e_r.png"                      alt=""                 ><br />之后再次点击 <code>Tools&gt;Open xx Project</code>,本文使用的是 <code>Rider</code>,<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_cb4c558e698ba807af0a66f86c75a617_r.png"                      alt=""                 ><br />值得注意的是，和C++挂钩的环境配置都很麻烦。</p><table><thead><tr><th>Unreal Engine Version</th><th>VS 2019 Version</th><th>VS 2022 Version</th></tr></thead><tbody><tr><td><strong>5.3</strong></td><td>16.11.5 or later</td><td>17.4 or later, 17.6 recommended (Default)</td></tr><tr><td><strong>5.2</strong></td><td>16.11.5 or later</td><td>17.4 or later (Default)</td></tr><tr><td><strong>5.1</strong></td><td>16.11.5 or later (Default)</td><td>17.4 or later</td></tr></tbody></table><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_fb9987b2cdb0d44b59df169cd454aeec_r.png"                      alt=""                 ></p><h2 id="使用c的actor"><a class="markdownIt-Anchor" href="#使用c的actor"></a> 使用C++的Actor</h2><p>就和正常创建 Actor 一样，选择蓝图类。<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_d9c80903ca032830032735add8677eb2_r.png"                      alt=""                 ></p><p>—待更新</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;ue-c-</summary>
      
    
    
    
    <category term="游戏开发" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="UE学习" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/UE%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Task</title>
    <link href="http://example.com/posts/3S4RX0V.html"/>
    <id>http://example.com/posts/3S4RX0V.html</id>
    <published>2024-12-31T14:45:02.373Z</published>
    <updated>2024-12-31T15:14:55.874Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="ue-多人协同"><a class="markdownIt-Anchor" href="#ue-多人协同"></a> UE 多人协同</h2><h2 id="程序化管道生成"><a class="markdownIt-Anchor" href="#程序化管道生成"></a> 程序化管道生成</h2><ul><li>[x] <a class="link"   href="https://www.bilibili.com/video/BV1Rt411G7EJ/" >Houdini+UE4 制作线条程序化管道_哔哩哔哩_bilibili<i class="fas fa-external-link-alt"></i></a></li><li>[x] <a class="link"   href="https://weibo.com/3749571965/LupwdCvJO" >Sina Visitor System<i class="fas fa-external-link-alt"></i></a></li><li>[x] <a class="link"   href="https://zhuanlan.zhihu.com/p/53039879" >Houdini 程序化通道框架生成(Unity,UE4) - 知乎<i class="fas fa-external-link-alt"></i></a></li></ul><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explorer C:\Users\<span class="number">123</span>\Documents\Unreal Projects\spawnline</span><br></pre></td></tr></table></figure><ul><li>[x] <a class="link"   href="https://www.bilibili.com/video/BV1U94y1Z7Hu/?share_source=copy_web&amp;vd_source=64becc8dd5f04c65092c107c1fe0a5e2" >【UE5】虚幻 5 动态水材质教程(一)_哔哩哔哩_bilibili<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="点位点击弹出框效果相关思路"><a class="markdownIt-Anchor" href="#点位点击弹出框效果相关思路"></a> 点位点击弹出框效果相关思路</h2><ul><li>[x] <a class="link"   href="https://blog.csdn.net/qq_41260655/article/details/123013358" >【精选】21 虚幻 4【UE4】鼠标碰撞检测(实现鼠标监听，从而实现点击场景模型(碰撞体)高亮函数)_ue setrendercustomdepth_Ezms 的博客-CSDN 博客<i class="fas fa-external-link-alt"></i></a></li></ul><p>(1)通过鼠标左键、中键、右键绑定点击事件</p><p>(2)通过函数<strong>ConverMouseLocationWorldSpace</strong>  将鼠标 2D 位置转化为三维世界的坐标</p><p>(3)通过函数<strong>LineTraceByChannel</strong>根据点击的坐标位置，方向进行延申，形成一条射线，射中的第一个碰撞体接收命中的监测<strong>OutHit</strong></p><p>(4)根据此 Actor 可设置其属性 RenderCustomDepth 高亮属性</p><ul><li>[x] <a class="link"   href="https://blog.csdn.net/qq_31788759/article/details/89418283" >【UE4 Blueprint】使用射线检测在鼠标点击处生成物体_ue4 打印鼠标点击的物体-CSDN 博客<i class="fas fa-external-link-alt"></i></a></li></ul><p>(1)生成一条从相机到鼠标点击位置方向的射线，在碰撞到的第一个 Location 生成 Actor 类</p><p>获得位置之后，在创建 UI 组件的时候，设置位置就行</p><h2 id="像素流送"><a class="markdownIt-Anchor" href="#像素流送"></a> 像素流送</h2><ul><li>[ ] <a class="link"   href="https://blog.csdn.net/dxs1990/article/details/131167273" >【UE5】分分钟简单使用像素流服务（Pixel Streaming）_pixelstreaming-CSDN 博客<i class="fas fa-external-link-alt"></i></a></li><li>[ ] <a class="link"   href="https://blog.csdn.net/weixin_43784914/article/details/127852696" >[虚幻引擎][UE][UE5]像素流送(Pixel Streaming)，像素流去掉黑边和按钮[UE5.1.0]，鼠标控制_涟涟涟涟的博客-CSDN 博客<i class="fas fa-external-link-alt"></i></a></li><li>[ ] <a class="link"   href="https://blog.csdn.net/m0_51171995/article/details/131097118?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-131097118-blog-131167273.235%5Ev38%5Epc_relevant_sort_base1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-131097118-blog-131167273.235%5Ev38%5Epc_relevant_sort_base1&amp;utm_relevant_index=2" >Vue3 中集成 Unreal 5.2 像素流(Pixel Streaming 插件)-CSDN 博客<i class="fas fa-external-link-alt"></i></a></li></ul><ol><li><strong>解释一下像素流送程序快捷方式的后缀命令</strong><br /><strong>-AudioMixer</strong>  像素流送默认是没有声音的，所以想要有声音，这个必须记得添加<br /><strong>-PixelStreamingIP=xxxx</strong>  像素流送的 IP 地址，这个可以根据需要修改<br /><strong>-PixelStreamingPort=xxxx</strong>  像素流送端口，同理也是可以修改的<br /><strong>-forceres</strong>强制运行，后面长接分辨率指令<br /><strong>-ResX=1920 -ResY=1080</strong>  设定分辨率 不用多说<br /><strong>-RenderOffScreen</strong>  如果不想打开像素流送窗口也想让程序流送，就使用这个命令，关闭时候可以在任务管理器中结束程序</li><li><strong>4.27 的 stun/turn 相关协议文件路径</strong><br />1.27 其实是没有 stun/turn 文件的，需要打包一个已经开启像素流送插件的 4.26 空项目，然后找到 release 文件夹，复制这个文件夹过来用，这个方法是可行的。</li><li><strong>使用 stun/turn 的时候记得要开启 19302 19303 两个端口</strong><br />开启方法百度一大把。</li><li><strong>为了方便开启一大堆程序，可以写一个. Bat 文件来执行</strong></li></ol><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.exe -PixelStreamingIP=localhost -PixelStreamingPort=<span class="number">7777</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;ue-多人</summary>
      
    
    
    
    <category term="游戏开发" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="UE学习" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/UE%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="http://example.com/posts/B91MGV.html"/>
    <id>http://example.com/posts/B91MGV.html</id>
    <published>2024-12-31T14:45:02.371Z</published>
    <updated>2024-12-31T14:45:02.371Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="一句话简述"><a class="markdownIt-Anchor" href="#一句话简述"></a> 一句话简述</h2><p>函数式函数式编程，是一种从数据流和数据关系的思考方式，可读性强且安全。<strong>Pay attention!!!</strong> 函数表示一切，包括数字。</p><h2 id="约定"><a class="markdownIt-Anchor" href="#约定"></a> 约定</h2><p>本文使用 <code>Dart</code> 语言描述，对于编程范式，具体是什么语言并不重要，只是顺手而已。</p><h2 id="为什么需要函数式编程"><a class="markdownIt-Anchor" href="#为什么需要函数式编程"></a> 为什么需要函数式编程</h2><h3 id="可预测-bug-少"><a class="markdownIt-Anchor" href="#可预测-bug-少"></a> 可预测、Bug 少</h3><p>函数式编程中，以函数为载体，数据流为驱动，数据是<strong>不允许篡改</strong>的，数据的操作是<strong>公开的</strong>，数据的流动是<strong>可预测</strong>的。这样就能很好的规避竞态问题。</p><h3 id="易于测试"><a class="markdownIt-Anchor" href="#易于测试"></a> 易于测试</h3><p>以函数为叙述单元，只需要知道数据的来源，对于数据的返回值是，正如之前所说，可预测的数据流，那么就很容易将用例拆分，从而做到测试。</p><h3 id="移植性高"><a class="markdownIt-Anchor" href="#移植性高"></a> 移植性高</h3><p>函数为思考主体，从而做到模块化。</p><h2 id="函数式编程是什么"><a class="markdownIt-Anchor" href="#函数式编程是什么"></a> 函数式编程是什么</h2><p>根据维基百科所述，<strong>函数式编程</strong>(又叫做<strong>函数程序设计</strong>、<strong>泛函编程</strong>、<strong>Functional Programing</strong>)，是一种编程范式，它将<a class="link"   href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E9%81%8B%E7%AE%97"  title="电脑运算">电脑运算<i class="fas fa-external-link-alt"></i></a>视为<a class="link"   href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0"  title="函数">函数<i class="fas fa-external-link-alt"></i></a>运算，并且避免使用程序[状态]( <a class="link"   href="https://zh.wikipedia.org/w/index.php?title=%E7%8A%B6%E6%80%81_" >https://zh.wikipedia.org/w/index.php?title=状态_<i class="fas fa-external-link-alt"></i></a> (%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&amp;action=edit&amp;redlink=1)以及<a class="link"   href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8F%AF%E8%AE%8A%E7%89%A9%E4%BB%B6"  title="不可变物件">可变物件<i class="fas fa-external-link-alt"></i></a>。从定义出发，有两个关键点：</p><ul><li>函数运算。<br />在 <strong>函数式编程</strong>中，函数就是头等公民，你可以将函数名当作变量赋值给其他变量，使用方式不受影响。比如</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 定义一个减法</span></span><br><span class="line">  <span class="built_in">int</span> minus(<span class="built_in">int</span> a,<span class="built_in">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义一个加法</span></span><br><span class="line">  <span class="keyword">var</span> add = (<span class="built_in">int</span> a,<span class="built_in">int</span> b)=&gt;a+b;</span><br><span class="line">  <span class="comment">// 将 minus 赋值给另外一个变量</span></span><br><span class="line">  <span class="keyword">var</span> minusTwo = minus;</span><br><span class="line">  <span class="comment">// 使用函数</span></span><br><span class="line">  <span class="built_in">print</span>(add(<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">// 输出 3</span></span><br><span class="line">  <span class="built_in">print</span>(minus_2(<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">// 输出 -1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>状态及可变性管理。<br /><strong>函数式编程</strong>中的特点是，纯函数，所谓纯函数是指相同的输入总会得到相同的输出，并且不会产生副作用的函数。</li></ul><p>这和数学中的关注点一样 <code>f(data) = (other_state_data)</code>，也就是 <code>dataIn</code>，<code>dataOut</code>，这个之间只是来自于我们的函数作用不同，进一步请关联一下数学中基本的函数基础，<code>单调性</code>、<code>对称性</code>、<code>复合函数</code>、甚至是一些其他复杂的概念，这是<strong>函数的切入点</strong>。<strong>数据的切入点</strong>则可以理解<strong>数据流</strong>，数据如同水流一样，在奔向大海的途中，有阻碍，有汇入，但是本质还是那一堆水的映射。所谓副作用，就是不污染全局，但是接受闭包。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的作用域</span></span><br><span class="line"><span class="keyword">var</span> globalVarity = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">dirty()&#123;</span><br><span class="line"><span class="comment">// 污染全局变量</span></span><br><span class="line">globalVarity++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 又一个函数调用</span></span><br><span class="line">dirtyTwo()&#123;</span><br><span class="line">globalVarity++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 那么在并发的时候,Opps 你猜是什么，这还是微任务的情况下，是可预见的。</span></span><br><span class="line">main()&#123;</span><br><span class="line">  <span class="keyword">while</span> ( globalVarity &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">0</span>),()&#123;</span><br><span class="line">      dirty();</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;for 1 <span class="subst">$globalVarity</span>&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">0</span>),()&#123;</span><br><span class="line">      dirtyTwo();</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;for 2 <span class="subst">$globalVarity</span>&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 篡改</span></span><br><span class="line">    globalVarity++;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 面目全非的 globalVarity;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数式编程与其他范式的区别"><a class="markdownIt-Anchor" href="#函数式编程与其他范式的区别"></a> 函数式编程与其他范式的区别</h2><h3 id="面向过程编程"><a class="markdownIt-Anchor" href="#面向过程编程"></a> 面向过程编程</h3><p>命令式编程，就是 <code>one by one</code>，这种思考方式偏向于原子化，经典的例子：把大象关进冰箱需要几步。面向对象的描述方式是说，第一步，打开冰箱，第二步装入冰箱，第三步关上冰箱。</p><h3 id="面向对象编程"><a class="markdownIt-Anchor" href="#面向对象编程"></a> 面向对象编程</h3><p>面向对象编程，将操作方式进行分类，让动作属于某一个对象，然后进行架构。依然以关大象举例，大象打开了冰箱（对象作用），大象走进了冰箱，大象关上了门。</p><h3 id="声明式编程-面向字典编程"><a class="markdownIt-Anchor" href="#声明式编程-面向字典编程"></a> 声明式编程 (面向字典编程 🧠)</h3><p>声明式编程，一切都已经安排好了，是一套预定的规则，比如 <code>CSS</code>，你只需要加上合适的属性，就能完成编程，底层已经为您做了实现。还是以上面关大象为例子，大象可以被装进冰箱，冰箱可以装大象。然后声明，大象在冰箱中。</p><h2 id="函数式编程起源λ-演算"><a class="markdownIt-Anchor" href="#函数式编程起源λ-演算"></a> 函数式编程起源：λ 演算</h2><p>λ 演算和图灵机等价（图灵完备，作为一种研究语言又很方便）。<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_086f2492cf70a9fe779091729ec91ce7_r.png"                      alt=""                 ><br />所以 λ 演算式就三个要点：</p><ol><li><p>绑定关系。变量任意性，x、y 和 z 都行，它仅仅是具体数据的代称。</p></li><li><p>递归定义。λ 项递归定义，M 可以是一个 λ 项。</p></li><li><p>替换归约。λ 项可应用，空格分隔表示对 M 应用 N，N 可以是一个 λ 项。</p></li></ol><p>比如这样的演算式：<br /><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_adee8c7c0fd29cba78632e5886d62b1c_r.png"                      alt=""                 ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_776f70e1187ddf8aaf49366f539b2ccd_r.png"                      alt=""                 ><br />上面的演算式表示有一个函数 f 和一个参数 x。令 0 为 x，1 为 f x，2 为 f f x…，这就像我们数学中的幂：a^x（a 的 x 次幂表示 a 对自身乘 x 次）。相应的，我们理解上面的演算式就是数字 n 就是 f 对 x 作用的次数。有了这个数字的定义之后，我们就可以在这个基础上定义运算。</p><p>对应到我们前端使用的结果其实就是</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 0 在函数中理解为不作为，就是什么都不做</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">zero</span> = f=&gt;<span class="function"><span class="params">x</span>=&gt;</span>x;</span><br><span class="line"><span class="comment">// 进入了一个层级</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">one</span> = f=&gt;<span class="function"><span class="params">x</span>=&gt;</span><span class="title function_">f</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义加法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">n,m</span>)=&gt;<span class="function"><span class="params">f</span>=&gt;</span><span class="function">()=&gt;</span><span class="title function_">m</span>(f)(<span class="title function_">n</span>(f)())</span><br><span class="line"><span class="comment">// 那么 2 就是</span></span><br><span class="line"><span class="keyword">const</span> two = <span class="title function_">add</span>(one,one)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给2传一个函数,会打印2次:</span></span><br><span class="line"><span class="title function_">two</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;print 2 times&#x27;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算数字3 = 1 + 2:</span></span><br><span class="line"><span class="keyword">let</span> three = <span class="title function_">add</span>(one, two);</span><br><span class="line"><span class="title function_">three</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;print 3 times&#x27;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在函数式编程的世界中，一切皆函数，函数是一等公民。一等公民这个名字听起来很高大上，但是也相当晦涩，这个词也不是翻译的不好，因为英文原文中叫 first class citizen 很多人包括我也不知所云。其实所谓一等公民，它的意思是函数与基本数据类型一样，可作为函数的入参，也可作为函数的返回值，函数可以赋值给变量。我们知道在平常的命令式编程语言中（例如 Java）中，函数的返回值比较简单，只能是基本数据类型（整型，布尔，字符串等）或者是一个 Object。而在 JavaScript 函数是第一公民，因此我们也可以在函数中返回函数。正因为有了这种属性，函数的入参可以是函数，函数的返回值可以是函数，于是便有了高阶函数，以及各种骚操作和一些看起来很炫酷的语法糖。可以说函数为第一公民是函数式编程的必要条件。</p><h2 id="前端中常见的-fp-概念"><a class="markdownIt-Anchor" href="#前端中常见的-fp-概念"></a> 前端中常见的 FP 概念</h2><p>From Functional Programming Jargon(opens new window)</p><ul><li>Higher-Order Functions (HOF)：高阶函数</li><li>Closure：闭包（数学集合中的概念）</li><li>Currying：柯里化</li><li>Function Composition：函数组合</li><li>Pure Function：纯函数</li><li>Side effects：副作用</li><li>Point-Free Style：隐式参数</li><li>Functor：函子</li><li>Lambda Calculus：Lambda 演算</li><li>Lazy evaluation：惰性求值</li></ul><h2 id="ramdajs"><a class="markdownIt-Anchor" href="#ramdajs"></a> <a class="link"   href="https://ramdajs.com/" >Ramdajs<i class="fas fa-external-link-alt"></i></a></h2><p>Ramda 主要特性如下：</p><ol><li>Ramda 强调更加纯粹的函数式风格。数据不变性和函数无副作用是其核心设计理念。这可以帮助你使用简洁、优雅的代码来完成工作。</li><li>Ramda 函数本身都是自动柯里化的。这可以让你在只提供部分参数的情况下，轻松地在已有函数的基础上创建新函数。</li><li>Ramda 函数参数的排列顺序更便于柯里化。要操作的数据通常在最后面。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_7918f55fbfb67840cfe5c7028ede8c32_r.png"                      alt=""                 ></p><h3 id="ramda-中有关-fp-概念的-api"><a class="markdownIt-Anchor" href="#ramda-中有关-fp-概念的-api"></a> Ramda 中有关 FP 概念的 API</h3><ul><li>partial</li><li>curry</li><li>lift</li><li>compose/pipe</li></ul><h2 id="rxjs"><a class="markdownIt-Anchor" href="#rxjs"></a> RxJS</h2><p>RxJS 是一个库，它通过使用 observable 序列来编写异步和基于事件的程序。它提供了一个核心类型 Observable，附属类型 (Observer、 Schedulers、 Subjects) 和受 [Array#extras] 启发的操作符 (map、filter、reduce、every, 等等)，这些数组操作符可以把异步事件作为集合来处理。</p><p>在 RxJS 中用来解决异步事件管理的的基本概念是：</p><ul><li>Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。</li><li>Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。</li><li>Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。</li><li>Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。</li><li>Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。</li><li>Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其他。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/m_fb4fc77e2fa5edbf80257209da9f9601_r.png"                      alt=""                 ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;一句话简述</summary>
      
    
    
    
    <category term="技术学习" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术学习" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="编程范式" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>实践中的算法</title>
    <link href="http://example.com/posts/3CPDVQ4.html"/>
    <id>http://example.com/posts/3CPDVQ4.html</id>
    <published>2024-12-31T14:45:02.370Z</published>
    <updated>2024-12-31T14:45:02.370Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="situation-task-action-result-star"><a class="markdownIt-Anchor" href="#situation-task-action-result-star"></a> <strong>Situation Task Action Result</strong> (STAR)</h2><h2 id="回溯算法"><a class="markdownIt-Anchor" href="#回溯算法"></a> 回溯算法</h2><h3 id="s-situation-寻找到目标节点的路径"><a class="markdownIt-Anchor" href="#s-situation-寻找到目标节点的路径"></a> S (Situation) 寻找到目标节点的路径</h3><ol><li><code>Vue</code> 项目中，需要实现侧边与路由关联，目录约定如下</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">RouteItem</span> &#123;</span><br><span class="line"><span class="attr">path</span>: <span class="built_in">string</span></span><br><span class="line"><span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line"><span class="attr">subs</span>: <span class="title class_">RouteItem</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Target</span> = <span class="title class_">RouteItem</span>[<span class="string">&quot;path&quot;</span>];</span><br></pre></td></tr></table></figure><h3 id="t-task"><a class="markdownIt-Anchor" href="#t-task"></a> T (Task)</h3><ol><li>找到 <code>Target</code> 在 <code>RouterItem</code> 中的 <code>path</code> 链路</li></ol><h3 id="a-action"><a class="markdownIt-Anchor" href="#a-action"></a> A (Action)</h3><ol><li>尝试了利用 <code>Vue.Router</code> 中的 <code>matched</code> 字段，但是发现和路由配置强关联了。想到路径算法，计算叶子路径，考虑到叶子路径关系，以及剪枝。采用算法实现如下。</li></ol><p>1.1 递归回溯</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findPath</span>(<span class="params">asides:RouteItem[], activeAside:Target,res:Target[][]=[],path=[]</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用路由建立映射</span></span><br><span class="line"><span class="comment">// 副本拷贝，初始入栈</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">stack</span>:<span class="title class_">RouteItem</span>[] = […asides];</span><br><span class="line"><span class="comment">// 开始深搜</span></span><br><span class="line"><span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line"><span class="comment">// 检出当前可进入分支</span></span><br><span class="line"><span class="keyword">const</span> cur = stack.<span class="title function_">pop</span>();</span><br><span class="line"><span class="comment">// 路径剪枝，因为路径都已经为空了，但是我们寻找的是path</span></span><br><span class="line"><span class="keyword">if</span> (!cur.<span class="property">path</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 如果存在路径，一股脑推进</span></span><br><span class="line"><span class="title function_">findPath</span>([...cur.<span class="property">subs</span>],activeAside,res,path.<span class="title function_">concat</span>(cur.<span class="property">path</span>));</span><br><span class="line"><span class="comment">// 拿到一次性的到叶子节点的路径</span></span><br><span class="line"><span class="comment">// preflight 检查是否是可行结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果是可行解,保留路径,注意拷贝方式</span></span><br><span class="line"><span class="keyword">if</span>(path.<span class="title function_">includes</span>(activeAside)) res.<span class="title function_">push</span>([…path]);</span><br><span class="line"><span class="comment">// 不管路径是否满足，因为已经向结果 push 了，不需要记录</span></span><br><span class="line">path.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.2 迭代回溯</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findPath</span>(<span class="params">asides:RouteItem[], activeAside:Target</span>) &#123;</span><br><span class="line">  <span class="comment">// 利用路由建立映射</span></span><br><span class="line">  <span class="comment">// 副本拷贝，初始入栈</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">stack</span>:<span class="title class_">RouteItem</span>[] = […asides];</span><br><span class="line">  <span class="comment">// 记录遍历路径</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">path</span>:<span class="title class_">Target</span> = [];</span><br><span class="line">  <span class="comment">// 记录可以解决的结果分支</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">res</span>:<span class="title class_">Target</span>[][] = [];</span><br><span class="line">  <span class="comment">// 开始深搜</span></span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line"><span class="comment">// 检出当前可进入分支</span></span><br><span class="line">    <span class="keyword">const</span> cur = stack.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="comment">// 路径剪枝，因为路径都已经为空了，但是我们寻找的是path</span></span><br><span class="line">    <span class="keyword">if</span> (!cur.<span class="property">path</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 推入路径</span></span><br><span class="line">    path.<span class="title function_">push</span>(cur.<span class="property">path</span>);</span><br><span class="line">    <span class="comment">// 如果存在路径，就一次性推入</span></span><br><span class="line">    <span class="keyword">if</span> (cur.<span class="property">subs</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(…cur.<span class="property">subs</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到一次性的到叶子节点的路径</span></span><br><span class="line">    <span class="comment">// preflight 检查是否是可行结果</span></span><br><span class="line">    <span class="keyword">if</span>(path.<span class="title function_">includes</span>(activeAside))&#123;</span><br><span class="line">    <span class="comment">// 如果是可行解,保留路径</span></span><br><span class="line">    res.<span class="title function_">push</span>([…path])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不管路径是否满足，因为已经向结果 push 了，不需要记录</span></span><br><span class="line">    path.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="r-result"><a class="markdownIt-Anchor" href="#r-result"></a> R (Result)</h3><ol><li>成功达到目的，最终结果如下</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findPath</span>(<span class="params">asides:RouteItem[], activeAside:Target</span>) &#123;</span><br><span class="line">  <span class="comment">// 利用路由建立映射</span></span><br><span class="line">  <span class="comment">// 副本拷贝，初始入栈</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">stack</span>:<span class="title class_">RouteItem</span>[] = […asides];</span><br><span class="line">  <span class="comment">// 记录遍历路径</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">path</span>:<span class="title class_">Target</span>[] = [];</span><br><span class="line">  <span class="comment">// 开始深搜</span></span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line"><span class="comment">// 检出当前可进入分支</span></span><br><span class="line">    <span class="keyword">const</span> cur = stack.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="comment">// 路径剪枝，因为路径都已经为空了，但是我们寻找的是path</span></span><br><span class="line">    <span class="keyword">if</span> (!cur.<span class="property">path</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 推入路径</span></span><br><span class="line">    path.<span class="title function_">push</span>(cur.<span class="property">path</span>);</span><br><span class="line">    <span class="comment">// 如果存在路径，就一次性推入</span></span><br><span class="line">    <span class="keyword">if</span> (cur.<span class="property">subs</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(...cur.<span class="property">subs</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到一次性的到叶子节点的路径</span></span><br><span class="line">    <span class="comment">// preflight 检查是否是可行结果</span></span><br><span class="line">    <span class="keyword">const</span> idx = path.<span class="title function_">findIndex</span>(<span class="function"><span class="params">p</span> =&gt;</span> p === activeAside);</span><br><span class="line">    <span class="comment">// 截取出路径，本次特定情况下可以直接截取</span></span><br><span class="line">    <span class="keyword">if</span> (idx !== -<span class="number">1</span>)  <span class="keyword">return</span> path.<span class="title function_">slice</span>(<span class="number">0</span>, idx + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 不管路径是否满足，因为已经向结果 push 了，不需要记录</span></span><br><span class="line">    path.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心系列"><a class="markdownIt-Anchor" href="#贪心系列"></a> 贪心系列</h2><blockquote><p>TODO</p></blockquote><h3 id="s-situation"><a class="markdownIt-Anchor" href="#s-situation"></a> S (Situation)</h3><p>需要实现一个效果：</p><h3 id="a-action-2"><a class="markdownIt-Anchor" href="#a-action-2"></a> A (Action)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="前缀树"><a class="markdownIt-Anchor" href="#前缀树"></a> 前缀树</h2><blockquote><p>TODO</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;situa</summary>
      
    
    
    
    <category term="技术学习" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术学习" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="算法" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
