<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="CouriourC"><title>操作系统知识点总结-进程同步 | CouriourC Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/avatar.jpg"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"example.com",root:"/",language:"zh-CN",path:"search.xml"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0,init_open:!1},style:{primary_color:"#0066CC",avatar:"/images/avatar.jpg",favicon:"/images/avatar.jpg",article_img_align:"left",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"在天冷的时候总会穿上秋裤"},scroll:{progress_bar:{enable:!0},percent:{enable:!0}}},local_search:{enable:!0,preload:!1},code_copy:{enable:!0,style:"default"},pjax:{enable:!0},lazyload:{enable:!0},version:"3.4.5"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><style type="text/css">.spoiler{display:inline-flex}p.spoiler{display:flex}.spoiler a{pointer-events:none}.spoiler-blur,.spoiler-blur>*{transition:text-shadow .5s ease}.spoiler .spoiler-blur,.spoiler .spoiler-blur>*{color:transparent;background-color:rgba(0,0,0,0);text-shadow:0 0 10px grey;cursor:pointer}.spoiler .spoiler-blur:hover,.spoiler .spoiler-blur:hover>*{text-shadow:0 0 5px grey}.spoiler-box,.spoiler-box>*{transition:color .5s ease,background-color .5s ease}.spoiler .spoiler-box,.spoiler .spoiler-box>*{color:#000;background-color:#000;text-shadow:none}</style><meta name="generator" content="Hexo 5.4.2"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style><link rel="alternate" href="/atom.xml" title="小客栈" type="application/atom+xml"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fas fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/"><img src="/images/avatar.jpg"> </a><a class="logo-title" href="/">CouriourC Blog</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item search search-popup-trigger"><i class="gg-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="gg-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">操作系统知识点总结-进程同步</span></div><div class="article-header"><div class="avatar"><img src="/images/avatar.jpg"></div><div class="info"><div class="author"><span class="name">CouriourC</span> <span class="author-label">Lv5</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp; <span class="pc">2022-09-12 14:10:33</span> <span class="mobile">2022-09-12 14:10</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a>&nbsp;</li><li>&gt; <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识 </a>&nbsp;</li><li>| <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统 </a>&nbsp;</li><li>| <a href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">进程管理 </a>&nbsp;</li><li>| <a href="/tags/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/">进程同步 </a>&nbsp;</li></ul></span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="进程同步的概念"><a class="markdownIt-Anchor" href="#进程同步的概念"></a> 进程同步的概念</h2><h3 id="临界资源"><a class="markdownIt-Anchor" href="#临界资源"></a> 临界资源</h3><p>临界资源指一个时间段内只允许一个进程使用的资源（互斥资源）。</p><blockquote><p>例如物理设备，内存缓冲区等都是临界资源</p></blockquote><p>在每一个进程中，访问临界资源的那部分指令被称为临界区，对临界区的访问可以分为四个阶段：</p><pre class="mermaid">sequenceDiagram

participant  entry as 进入区域 
participant  crisis as 临界区 
participant exit as 退出区
participant remainder as 剩余区

loop always
 entry  --&gt; remainder: 
end</pre><ul><li><strong>进入区</strong>：检查是否可以进入临界区，若可以进入，则设置正在访问临界资源的标志，以阻止其他进程进入临界区。</li><li><strong>临界区</strong>（<strong>临界段</strong>）：进程中访问临界区的一段代码。</li><li><strong>退出区</strong>：将正在访问临界资源的标志解除。</li><li><strong>剩余区</strong>：代码中其他部分。</li></ul><p><span style="color:red">🧡进入区和退出区负责实现互斥</span></p><h2 id="同步"><a class="markdownIt-Anchor" href="#同步"></a> 同步</h2><p><strong>同步</strong>：亦称为<strong>直接制约关系</strong>，他是指完成某种任务而建立的<strong>两个或多个</strong>进程，这些进程因为需要在某些位置上协调他们的工作次序而产生的制约关系。进程间的<strong>直接制约关系</strong>就是因为他们的相互合作。</p><h2 id="互斥"><a class="markdownIt-Anchor" href="#互斥"></a> 互斥</h2><p>对临界资源的访问，<strong>必须</strong>互斥的进行。</p><p>互斥：亦称<strong>间接制约关系</strong>，进程互斥指当一个进程访问临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束。释放该资源之后，另一个进程才能去访问临界资源。</p><h3 id="互斥的原则"><a class="markdownIt-Anchor" href="#互斥的原则"></a> 互斥的原则</h3><ul><li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程，立即进入临界区。</li><li>忙则等待：若已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li><li>有限等待：对请求访问的进程，因保证能在有限时间内进入临界区（保证不饥饿）</li><li>让权等待：当进程不能进入临界区时，应立刻释放处理机，防止进程忙等待。</li></ul><blockquote><p>一句话，就是 <strong>（处理机or资源）物尽其用</strong>，<strong>(能力or资源)不够就等</strong></p></blockquote><h2 id="临界区互斥的实现"><a class="markdownIt-Anchor" href="#临界区互斥的实现"></a> 临界区互斥的实现</h2><h3 id="单标志法"><a class="markdownIt-Anchor" href="#单标志法"></a> 单标志法</h3><p>一个进程在访问完临界区后会把临界区资源的权限交给另一个进程，也就是说每个进程进入临界区的权限只能由前辈（另一个程序赋予）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p0</span> <span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">while</span> (turn != <span class="number">0</span>);</span><br><span class="line">    critical section;</span><br><span class="line">    turn = <span class="number">1</span>;</span><br><span class="line">    remainder section;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p1</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(turn != <span class="number">1</span>);</span><br><span class="line">    critical section;</span><br><span class="line">    turn = <span class="number">0</span>;</span><br><span class="line">    remainder section;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就如同单锁一样，自己在用的时候，其他进程就不能用，自己用完了，立马就把占有权给人家。</p><blockquote><p>好比如：现在是桌上只有一双筷子，有A跟B两个人，一开始先把筷子给A，A吃完后直接就把筷子洗干净给B了，然后说你吃完再把筷子洗干净给我，结果B无语了，他也没说要用筷子吃东西，然后A就是说不管，你必须吃完过后再把筷子给我，结果A自己又想吃的时候结果没有筷子用，因为筷子还在B那里呢，B还在纳闷A怕不是有什么大病。<br>该比喻来自 CSDN「叫我蘑菇先生」的<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43305485/article/details/120754983">原创文章<i class="fas fa-external-link-alt"></i></a></p></blockquote><h3 id="双标志先检查法"><a class="markdownIt-Anchor" href="#双标志先检查法"></a> 双标志先检查法</h3><p>设置一个数组，相应元素标识进程访问的资源的意愿。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[] = {<span class="literal">false</span>,<span class="literal">false</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p0</span><span class="params">()</span></span>{</span><br><span class="line"> <span class="comment">// 或者 用 if (flag[1]) return ;</span></span><br><span class="line"> <span class="comment">//大抵就是，如果 1 占有的时候，就不继续执行下面的，</span></span><br><span class="line">    <span class="keyword">while</span> (flag[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 表明自己在占有</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 拿到临界区资源</span></span><br><span class="line">    critical section;</span><br><span class="line">    <span class="comment">// 自己用好了</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 退回资源</span></span><br><span class="line">    remaider section;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p1</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 拿到临界区资源</span></span><br><span class="line">    critical section;</span><br><span class="line">    <span class="comment">// 自己用好了</span></span><br><span class="line">    falg[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"> <span class="comment">// 退回资源</span></span><br><span class="line">    remaider section;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>相当于时各自等待别人表态，如果别人不用了，自己再用；可能<strong>违背忙则等待</strong>的原则。</p><blockquote><p>好比如：现在同样是桌上只有一双筷子，有A跟B两个人，但是现在这两个人会察言观色了，会先看对方会不会想要先用筷子，然后再判断下一步是使用筷子还是接着等待。一开始，两个人都不说自己想不想用筷子，就等对方先表态，毕竟要多谦让，最后彼此看这么久都不说话，估计就是不想用了，然后彼此都默认对方不想用筷子。这个时候就会出现问题了，两个人都默认彼此不想用筷子，然后自己就下意识去拿筷子，结果刚好对方也想用，这就尴尬了，那最后是谁用呢，这个时候就会出现资源被同时访问的问题。</p><p>该比喻来自 CSDN「叫我蘑菇先生」的<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43305485/article/details/120754983">原创文章<i class="fas fa-external-link-alt"></i></a></p></blockquote><hr><h3 id="双标志后检查法"><a class="markdownIt-Anchor" href="#双标志后检查法"></a> 双标志后检查法</h3><p>相比于双标志先检查法，此算法先修改自己的一员，再进行检查。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[] = { <span class="literal">false</span>,<span class="literal">false</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(<span class="type">bool</span> &amp;which)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(which);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p0</span><span class="params">()</span></span>{</span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">wait</span>(flag[<span class="number">1</span>]);</span><br><span class="line">    critical section;</span><br><span class="line"> flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    remainder section;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p1</span><span class="params">()</span></span>{</span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">wait</span>(flag[<span class="number">0</span>]);</span><br><span class="line">    critical section;</span><br><span class="line"> flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    remainder section;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这一算法解决了“忙则等待”的问题，但是若两个进程同时标记为true，又会相互等待造成<strong>饥饿</strong>，违背了“<strong>空闲让进</strong>”和“<strong>有限等待</strong>”原则。</p><blockquote><p>好比如：现在还是桌上只有一双筷子，但是现在就不是A跟B了，换成孔融1号和孔融2号，为什么给他们这样取名字呢，后面就知道啦！现在这两个人呢，在想用筷子的时候都会先说出来表明自己的态度，然后再看对方会不会想要先用筷子，然后再判断下一步是使用筷子还是接着等待。如果一开始两个人同时表明自己想要筷子的话，对方都会考虑到礼仪问题，谦让给对方用，毕竟谁叫他们叫孔融呢，但是这样出现的问题就是明明有筷子可以用但是因为谦让而僵持住。结果两个人就只能饿着了，在操作系统里面这里就出现了"死等"，即会存在进程产生"饥饿"。</p><p>该比喻来自 CSDN「叫我蘑菇先生」的<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43305485/article/details/120754983">原创文章<i class="fas fa-external-link-alt"></i></a></p></blockquote><hr><h3 id="peterson-算法"><a class="markdownIt-Anchor" href="#peterson-算法"></a> Peterson 算法</h3><p>基本思路：设置一个数组<code>flag[2]</code>，这里与前面不同之处，先设置自己的标志位，再检查对方的标志状态，若对方的标志位为 <code>true</code>，再检查对方的标志状态，若对方的标志位为 <code>true</code> 则等待，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[] = {<span class="literal">false</span>,<span class="literal">false</span>};</span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p0</span><span class="params">()</span></span>{</span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>;              <span class="comment">//标记P0希望进入临界区</span></span><br><span class="line"> turn = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"> <span class="built_in">wait</span>(flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>);</span><br><span class="line">    critical section;</span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    remainder section;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p1</span><span class="params">()</span></span>{</span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    turn = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">wait</span>(flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);</span><br><span class="line">    critical section;</span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    remainder section;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><blockquote><p>此算法利用flag[ ]实现了临界资源的<strong>互斥访问</strong>，并用<strong>turn</strong>解决了“<strong>饥饿</strong>”现象；</p><p>遵循了空闲让进、忙则等待和有限等待原则；</p><p>但是<strong>没有遵循让权等待原则</strong>（需要在CPU上不断循环检测）。</p></blockquote><h2 id="硬件实现"><a class="markdownIt-Anchor" href="#硬件实现"></a> 硬件实现</h2><h3 id="中断屏蔽方法"><a class="markdownIt-Anchor" href="#中断屏蔽方法"></a> 中断屏蔽方法</h3><p>利用开关中断的方式实现</p><pre class="mermaid">graph TB
close(关中断)
critical(临界区)
open(开中断)
close--"关中断之后不允许当前进程被关闭"--&gt;critical--&gt;open</pre><h4 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h4><ul><li>简洁，高校</li></ul><h4 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h4><ul><li><p>不适用于多处理机</p></li><li><p>只适用于操作系统内核进程（开关中断只能在内核执行）</p></li></ul><h3 id="tsltestandset指令"><a class="markdownIt-Anchor" href="#tsltestandset指令"></a> TSL(TestAndSet)指令</h3><p><strong>TS/TSL</strong> 指令时用<strong>硬件</strong>实现的，执行过程不允许被中断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> lock;  <span class="comment">//共享变量表示临界资源是否上锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TSL</span><span class="params">(<span class="type">bool</span> &amp;g_lock)</span></span>{</span><br><span class="line">    <span class="type">bool</span> old = g_lock;</span><br><span class="line">    g_lock = <span class="literal">true</span>;   <span class="comment">//无论之前是否上锁，将lock设置为true</span></span><br><span class="line">    <span class="keyword">return</span> old; <span class="comment">//返回之前lock的值</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p0</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">TSL</span>(lock));<span class="comment">//若可以进入临界区，则进入循环</span></span><br><span class="line">    critical section;</span><br><span class="line">    lock = <span class="literal">false</span>;  <span class="comment">//为临界资源解锁</span></span><br><span class="line">    remainder section;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2"></a> 优点</h3><ul><li>实现简单</li><li>适用于多处理机环境</li></ul><h4 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h4><ul><li>不满足让权等待原则，暂时无法进入临界区的资源任然会占用 <strong>CPU</strong> 并循环执行 <code>TS</code> 指令，导致**“忙等”**</li></ul><h3 id="swap-指令"><a class="markdownIt-Anchor" href="#swap-指令"></a> Swap 指令</h3><p>也称之为 <strong>Exchange</strong> 指令，或者简称 <strong>XCHG</strong>。</p><p>该指令和 <strong>TSL</strong> 类似，都是用硬件实现的，执行过程不允许被中断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">bool</span> &amp;a,<span class="type">bool</span> &amp;b)</span> </span>{</span><br><span class="line">    a = a^b;</span><br><span class="line">    b = a^b;</span><br><span class="line">    a = a^b;</span><br><span class="line">}</span><br><span class="line"><span class="type">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p0</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">while</span> (old== <span class="literal">true</span>) <span class="built_in">Swap</span>(old,lock);</span><br><span class="line">    critical section;</span><br><span class="line">    lock = <span class="literal">false</span>;</span><br><span class="line">    remainder section;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其原理，优缺点和 <strong>TSL</strong> 类似。</p><h2 id="锁自旋锁"><a class="markdownIt-Anchor" href="#锁自旋锁"></a> 🔒锁（自旋锁🔒）</h2><p>解决临界区最简单的方法就是锁。进程在进入临界区时获得锁，退出临界区时释放锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> locked;<span class="comment">//设置是否被锁的状态 true,已锁， false,未锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (locked) <span class="keyword">return</span>; <span class="comment">// 没有上锁就不管</span></span><br><span class="line">    </span><br><span class="line">    lock = <span class="literal">true</span>; <span class="comment">// 加锁</span></span><br><span class="line"> <span class="built_in">wait_unlock</span>(); <span class="comment">// 做一些东西，做完之后就 unlock</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span> <span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    locked = <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// or </span></span><br><span class="line"><span class="type">bool</span> available;</span><br><span class="line"><span class="comment">// 获得锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">acquire</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(!available); <span class="comment">//忙等锁，注意和 nodejs 不一样，nodejs 的话就直接卡在这里超时了，而这里主要考虑的是，喔，实测这玩意在 CPP 也寄，估计这玩意需要用在多处理器之间，嗯，对，这里就是讨论的不同进程之间。</span></span><br><span class="line">    available = <span class="literal">false</span>; <span class="comment">//获得锁</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span>{</span><br><span class="line">    available = <span class="literal">true</span>; <span class="comment">//释放锁</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同第一种一样，把释放加锁放到中间更加自然，就不要一直 while;</span></span><br></pre></td></tr></table></figure><p>上锁和解锁必须时原子操作。</p><h3 id="优点-3"><a class="markdownIt-Anchor" href="#优点-3"></a> 优点</h3><ul><li>等待器件不用切换进程上下文，多核处理器中若上锁的时间很短，则等待代价很低。</li><li>常用于多处理器系统，一个核忙等待，其他核正常工作，并快速释放临界区。</li></ul><h3 id="缺点-3"><a class="markdownIt-Anchor" href="#缺点-3"></a> 缺点</h3><ul><li>需要忙等，进程时间片用完才释放处理机资源，违反了“<strong>让权等待</strong>”</li><li>不适用于单处理机系统，忙等过程不可解锁。</li></ul><h2 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h2><p>信号量是一种功能较强的机制，可用于解决互斥与同步问题。他只能被两个标准原语 “<strong>Walit(S)</strong>” 和 **“Signal(S)”**访问，也被记作 “<strong>P操作</strong>” “<strong>V操作</strong>”。</p><blockquote><p>ℹ️在荷兰文中，通过叫passeren，释放叫vrijgeven，PV操作因此得名</p></blockquote><h3 id="整型信号量"><a class="markdownIt-Anchor" href="#整型信号量"></a> 整型信号量</h3><p>🚨一个整型的变量作为信号量，用来标识系统中某种资源的数量。</p><p>与普通整型变量相比，信号量只有三种原子操作: <strong>初始化</strong>、<strong>P 操作</strong>、<strong>V 操作</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">()</span> </span>{    <span class="comment">//wait原语，相当于进入区</span></span><br><span class="line">    <span class="keyword">while</span> ( S &lt;= <span class="number">0</span> ) ; <span class="comment">//若资源不够，则一直等待</span></span><br><span class="line">    S = S - <span class="number">1</span>;   <span class="comment">//若资源够，则使用/消耗这个资源</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">()</span></span>{ <span class="comment">// signal 原语</span></span><br><span class="line">    S = S + <span class="number">1</span>; <span class="comment">// 释放资源</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于 <strong>P操作</strong> 中资源不够时会一直等待，所以不能满足让权等待，会发生<strong>忙等</strong>。</p><h3 id="记录型信号量"><a class="markdownIt-Anchor" href="#记录型信号量"></a> 记录型信号量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">process</span> *L;</span><br><span class="line">} semapher;</span><br></pre></td></tr></table></figure><p>在记录型变量中，除了代表资源数量的 <strong>value</strong> 之外，还有一个进程链表 <strong>L</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(semapher S)</span> </span>{</span><br><span class="line">    S.value --;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">block</span>(S.L);<span class="comment">// 资源数量不足，则使用block原语将进程阻塞，并加入等待队列之中</span></span><br><span class="line">    }</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">(semapher S)</span></span>{</span><br><span class="line">    S.value ++;</span><br><span class="line">    <span class="keyword">if</span> ( S.value &lt;=<span class="number">0</span> ){</span><br><span class="line">        <span class="built_in">wakeup</span>(S.L);  <span class="comment">//若释放资源后可还有进程在等待，则唤醒该进程，使其从阻塞态变为就绪态</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>此机制遵循了让权等待原则，不会发生“<strong>忙等</strong>”。</p><h2 id="用信号量实现进程同步-互斥"><a class="markdownIt-Anchor" href="#用信号量实现进程同步-互斥"></a> 用信号量实现进程同步、互斥</h2><h3 id="进程互斥"><a class="markdownIt-Anchor" href="#进程互斥"></a> 进程互斥</h3><p>互斥的重点其实就是保证只有一个进程访问，那么这样的话其实就是加锁，上锁的过程。所以 PV 会成对出现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P1</span> <span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">    <span class="built_in">P</span>(mutex); <span class="comment">// 申请进入临界区</span></span><br><span class="line">    critical section ;<span class="comment">// 获得临界区资源</span></span><br><span class="line">    <span class="built_in">V</span>(mutex); <span class="comment">// 释放资源</span></span><br><span class="line">   <span class="built_in">do_something</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P2</span> <span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">    <span class="built_in">P</span>(mutex); <span class="comment">// 申请进入临界区</span></span><br><span class="line">    critical section ;<span class="comment">// 获得临界区资源</span></span><br><span class="line">    <span class="built_in">V</span>(mutex); <span class="comment">// 释放资源</span></span><br><span class="line">   <span class="built_in">do_something</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>ℹ️ 可以理解为此信号量表示进入临界区的名额，并且只有一个。</p><blockquote><p>🚨 需要为不同的临界资源设置不同的互斥信号量,PV 操作必须成对出现。</p></blockquote><h3 id="进程同步"><a class="markdownIt-Anchor" href="#进程同步"></a> 进程同步</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semphore S = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P1</span><span class="params">()</span></span>{</span><br><span class="line">   <span class="built_in">do_something</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="built_in">do_something</span>(<span class="number">2</span>);</span><br><span class="line">   <span class="built_in">V</span>(S);</span><br><span class="line">   <span class="built_in">do_something</span>(<span class="number">3</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P2</span> <span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">P</span>(S);</span><br><span class="line"> <span class="built_in">do_something</span>(<span class="number">4</span>);    </span><br><span class="line"> <span class="built_in">do_something</span>(<span class="number">5</span>);    </span><br><span class="line"> <span class="built_in">do_something</span>(<span class="number">6</span>);    </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只有 <code>do_something</code>1和2 执行完毕，且进行了<strong>V操作</strong>之后，进程2中的<strong>P操作</strong>才不会阻塞，并且能够继续执行下去。</p><h2 id="信号量实现前驱关系"><a class="markdownIt-Anchor" href="#信号量实现前驱关系"></a> 信号量实现前驱关系</h2><pre class="mermaid">graph TB
%%{init:{'theme':'forest'}}%%


s1((S1))
s2((S2))
s2((S2))
s3((S3))
s4((S4))
s5((S5))
s6((S6))

s1--a=0--&gt;s2
s1--b=0--&gt;s3
s3--c=0--&gt;s6
s2--d=0--&gt;s4
s2--e=0--&gt;s5
s4--f=0--&gt;s6
s5--g=0--&gt;s6

linkStyle 0,1,2,3,4,5,6 stroke:#7BCCAC,stroke-width:4px;</pre><ol><li><p>需要为每一对前去关系设置一个同步信号量</p></li><li><p>在前操作之后对相应的同步信号量执行 <strong>V 操作</strong></p></li><li><p>在后操作之前对相应的同步信号量执行 <strong>P 操作</strong></p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P1</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">// 执行 S1 内容</span></span><br><span class="line">    S1;</span><br><span class="line">    <span class="comment">// V 操作可以认为是放回结果，放回共享资源</span></span><br><span class="line">    <span class="built_in">V</span>(a); <span class="comment">// or signal(a);</span></span><br><span class="line">    <span class="built_in">V</span>(b); <span class="comment">// or signal(b);</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P2</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">P</span>(a);</span><br><span class="line">    <span class="comment">// 执行 S2 内容</span></span><br><span class="line">    S2;</span><br><span class="line">    <span class="comment">// V 操作可以认为是放回结果，放回共享资源</span></span><br><span class="line">    <span class="built_in">V</span>(d); <span class="comment">// or signal(a);</span></span><br><span class="line">    <span class="built_in">V</span>(e); <span class="comment">// or signal(b);</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P3</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">P</span>(b);</span><br><span class="line">    <span class="comment">// 执行 S3 内容</span></span><br><span class="line">    S3;</span><br><span class="line">    <span class="comment">// V 操作可以认为是放回结果，放回共享资源</span></span><br><span class="line"> <span class="built_in">V</span>(c);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P4</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">// 执行 S1 内容</span></span><br><span class="line">    <span class="built_in">P</span>(d);</span><br><span class="line">    S4;</span><br><span class="line">    <span class="comment">// V 操作可以认为是放回结果，放回共享资源</span></span><br><span class="line"> <span class="built_in">V</span>(f);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P5</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">P</span>(e);</span><br><span class="line">    <span class="comment">// 执行 S5 内容</span></span><br><span class="line">    S5;</span><br><span class="line">    <span class="comment">// V 操作可以认为是放回结果，放回共享资源</span></span><br><span class="line"> <span class="built_in">V</span>(g);</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P6</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">P</span>(c);</span><br><span class="line">    <span class="built_in">P</span>(f);</span><br><span class="line">    <span class="built_in">P</span>(g);</span><br><span class="line">    <span class="comment">// 执行 S1 内容</span></span><br><span class="line">    S6;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><blockquote><p>🚦 个人理解：其实这玩意就是 AOV 拓扑排序，具体应用有点像共享变量求和。共享资源的位置就像寄存器一样，保存操作结果，然后 <strong>P</strong> 取出，<strong>V</strong> 放入。</p></blockquote><h2 id="管程"><a class="markdownIt-Anchor" href="#管程"></a> 管程</h2><p><a class="link" target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/9175303">信号量机制<i class="fas fa-external-link-alt"></i></a>的缺点：进程自备<a class="link" target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%90%8C%E6%AD%A5/984802">同步<i class="fas fa-external-link-alt"></i></a>操作，P(S)和V(S)操作大量分散在各个进程中，不易管理，易发生死锁。1974年和1977年，Hore和Hansen提出了管程。</p><blockquote><p>这玩意还是看国外的吧 🤕，国内名词管程，莫名其妙的</p></blockquote><p>Monitors are a programming language component that aids in the regulation of shared data access. The Monitor is a package that contains shared data structures, operations, and synchronization between concurrent procedure calls. Therefore, a monitor is also known as a synchronization tool. <strong>Java, C#, Visual Basic, Ada, and concurrent Euclid</strong> are among some of the languages that allow the use of monitors. Processes operating outside the monitor can’t access the monitor’s internal variables, but they can call the monitor’s procedures.</p><p><strong>管程</strong>是一种帮助管理共享数据访问编程语言 组件/包。 Monitor 是包含共享数据结构、操作和并发过程调用之间的同步处理的包。 因此，<strong>管程</strong>也称为同步工具。 <strong>Java、C#、Visual Basic、Ada 和 concurrent Euclid</strong> 都是一些允许使用<strong>管程</strong>的编程语言。 在<strong>管程</strong>之外运行的进程不允许访问<strong>管程</strong>的内部变量，但它们可以调用<strong>管程</strong>的过程。</p><p><strong>For example</strong>, synchronization methods like the wait() and notify() constructs are available in the Java programming language.</p><p><strong>例如</strong>，<strong>Java</strong> 编程语言中提供了诸如 wait() 和 notify() 构造类的同步方法</p><h3 id="syntax-of-monitor-in-os操作系统中的管程"><a class="markdownIt-Anchor" href="#syntax-of-monitor-in-os操作系统中的管程"></a> Syntax of monitor in OS（操作系统中的管程）</h3><p>Monitor in os has a simple syntax similar to how we define a class, it is as follows:（这句就不翻译了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Monitor monitorName{</span><br><span class="line">    variables_declaration;</span><br><span class="line">    condition_variables;</span><br><span class="line">    </span><br><span class="line">    procedure p1{ ... };</span><br><span class="line">    procedure p2{ ... };</span><br><span class="line">    ...</span><br><span class="line">    procedure pn{ ... };</span><br><span class="line">    </span><br><span class="line">    {</span><br><span class="line">        initializing_code;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="characteristics-of-monitors-in-os管程的特征"><a class="markdownIt-Anchor" href="#characteristics-of-monitors-in-os管程的特征"></a> Characteristics of Monitors in OS（管程的特征）</h3><p>A monitor in os has the following characteristics:</p><ul><li>We can only run one program at a time inside the monitor.</li><li>Monitors in an operating system are defined as a group of methods and fields that are combined with a special type of package in the os.</li><li>A program cannot access the monitor’s internal variable if it is running outside the monitor. Although, a program can call the monitor’s functions.</li><li>Monitors were created to make synchronization problems less complicated.</li><li>Monitors provide a high level of synchronization between processes.</li></ul><p>一个管程应该有以下几种特征：</p><ul><li>只能在<strong>管程</strong>内同时运行一个程序。</li><li>操作系统中的<strong>管程</strong>被定义为一组方法和字段，它们与操作系统中的一种特殊类型的包结合使用。</li><li>在<strong>管程</strong>外部运行的程序<strong>不允许</strong>访问<strong>管程</strong>内部变量，哪怕是一个能调用管程函数的程序也 哒咩 🤕</li><li><strong>管程</strong>的出现是为了使同步问题不那么复杂</li><li><strong>管程</strong>在进程之间提供一个<strong>高级</strong>同步</li></ul><h3 id="components-of-monitor-in-an-operating-system管程的组成"><a class="markdownIt-Anchor" href="#components-of-monitor-in-an-operating-system管程的组成"></a> Components of Monitor in an operating system(管程的组成)</h3><p>The monitor is made up of four primary parts:</p><ol><li><strong>Initialization:</strong> The code for initialization is included in the package, and we just need it once when <strong>creating the monitors</strong>.</li><li><strong>Private Data:</strong> It is a feature of the monitor in an operating system to make the data private. It holds all of the monitor’s secret data, which includes private functions that may only be utilized within the monitor. As a result, private fields and functions are not visible outside of the monitor.</li><li><strong>Monitor Procedure:</strong> Procedures or functions that can be invoked from outside of the monitor are known as <strong>monitor procedures</strong>.</li><li><strong>Monitor Entry Queue:</strong> Another important component of the monitor is the Monitor Entry Queue. It contains all of the threads, which are commonly referred to as procedures only.</li></ol><p>管程由以下四个基本部分构成：</p><ol><li><p><strong>初始化：<strong>初始化管程的指令在包中，只需要在</strong>创建管程时</strong>调用一次。</p></li><li><p><strong>私有数据：</strong> 将数据私有化是管程的一个功能。它存储了管程中所有私有数据，包括只管程内使用的私有函数。所以，私有字段和函数在管程之外是不可见的。</p></li><li><p><strong>监控程序：<strong>可以从管程外部调用的程序或函数称为</strong>监控程序</strong>。(insight)</p></li><li><p><strong>管程入口队列：管程入口队列</strong>是<strong>管程</strong>的另一个重要部分，它包含进程所有线程，也就是所说的程序。</p></li></ol><h3 id="condition-variables条件变量"><a class="markdownIt-Anchor" href="#condition-variables条件变量"></a> Condition Variables（条件变量）</h3><p>There are two sorts of operations we can perform on the monitor’s condition variables:</p><ol><li>Wait</li><li>Signal</li></ol><p>Consider a condition variable (y) is declared in the monitor:</p><p><strong>y.wait():</strong> The activity/process that applies the wait operation on a condition variable will be suspended, and the suspended process is located in the condition variable’s block queue.</p><p><strong>y.signal():</strong> If an activity/process applies the signal action on the condition variable, then one of the blocked activity/processes in the monitor is given a chance to execute.</p><p>我们可以对管程中的条件变量执行两种操作：</p><ol><li>Wait（<strong>P操作</strong>)</li><li>Signal (<strong>V 操作</strong>)</li></ol><p>假设在<strong>管程</strong>中声明了一个条件变量 (y)：</p><p><strong>y.wait():</strong> 对条件变量执行 <strong>P 操作</strong>的 <strong>活动/进程</strong> 将被挂起，挂起的进程位于条件变量的阻塞队列。</p><p><strong>y.signal():</strong> 如果一个 <strong>活动/进程</strong> 对条件变量执行 V 操作，那么监视器中被阻塞的活动/进程之一就有机会执行。</p><blockquote><p>可以简单理解为资源的<strong>等待队列</strong>，一个条件变量代表一种阻塞的原因</p><p>条件变量的调用使用signal/wait</p><p>条件变量无法实现互斥，实际使用一般与锁配合使用</p></blockquote><h3 id="与信号量方法的区别"><a class="markdownIt-Anchor" href="#与信号量方法的区别"></a> 与信号量方法的区别</h3><table><thead><tr><th><strong>Monitors</strong></th><th><strong>Semaphore</strong></th></tr></thead><tbody><tr><td>We can use condition variables only in the monitors.</td><td>In semaphore, we can use condition variables anywhere in the program, but we cannot use conditions variables in a semaphore.</td></tr><tr><td>In monitors, wait always block the caller.</td><td>In semaphore, wait does not always block the caller.</td></tr><tr><td>The monitors are comprised of the shared variables and the procedures which operate the shared variable.</td><td>The semaphore S value means the number of shared resources that are present in the system.</td></tr><tr><td>Condition variables are present in the monitor.</td><td>Condition variables are not present in the semaphore.</td></tr></tbody></table><h3 id="advantages-of-monitor-in-os"><a class="markdownIt-Anchor" href="#advantages-of-monitor-in-os"></a> Advantages of Monitor in OS</h3><ul><li>Monitors offer the benefit of making concurrent or parallel programming easier and less error-prone than semaphore-based solutions.</li><li>It helps in process synchronization in the operating system.</li><li>Monitors have built-in mutual exclusion.</li><li>Monitors are easier to set up than semaphores.</li><li>Monitors may be able to correct for the timing faults that <strong>semaphores cause</strong>.</li></ul><h3 id="disadvantages-of-monitor-in-os"><a class="markdownIt-Anchor" href="#disadvantages-of-monitor-in-os"></a> Disadvantages of Monitor in OS</h3><ul><li>Monitors must be <strong>implemented</strong> with the programming language.</li><li>Monitor increases the compiler’s workload.</li><li>The monitor requires to understand what <strong>operating system</strong> features are available for <strong>controlling crucial</strong> sections in the parallel procedures.</li></ul><h3 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion"></a> Conclusion</h3><ul><li>Monitor in an operating system is one method for achieving process synchronization.</li><li>Monitors in OS offer the benefit of making concurrent or parallel programming easier and less error-prone than semaphore-based solutions.</li><li>The monitor is made up of four primary parts, Initialization, Private Data, Monitor Procedure, and Monitor Entry Queue.</li><li>wait() and signal() are two methods that we can use with the <strong>monitor’s condition variables</strong>.</li></ul></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">#基础知识</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">#操作系统</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">#进程管理</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/">#进程同步</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/posts/e5d70896.html"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">操作系统知识点总结-进程同步问题</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/posts/4fd8d774.html"><span class="title flex-center"><span class="post-nav-title-item">操作系统知识点总结-进程调度算法</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comment-anchor"></div><div class="comment-area-title"><i class="fas fa-comments">&nbsp;评论</i></div><div id="gitalk-container"></div><script data-pjax src="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script><script data-pjax>function loadGitalk(){let e=decodeURI(location.pathname);50<e.length&&(e=e.substring(0,47)+"...");try{Gitalk&&new Gitalk({clientID:"89b09c1ace1068a64740",clientSecret:"a790fd5655b56ce21a8462dc286b9e913592d742",repo:"couriourc.blog_talk",owner:"couriourc",admin:["couriourc"],id:e,language:"zh-CN"}).render("gitalk-container")}catch(e){window.Gitalk=null}}{const e=setTimeout(()=>{loadGitalk(),clearTimeout(e)},1e3)}</script></div></div></div></div><div class="social-share w-full flex-center" data-sites="weibo, qq, qzone,wechat"></div><script>let mermaidLoad=document.createElement("script");function init(){document.head.append(mermaidLoad),setTimeout(()=>{mermaid?.initialize({})})}mermaidLoad.src="https://unpkg.com/mermaid@9.1.2/dist/mermaid.min.js",mermaidLoad.addEventListener("load",init),document.addEventListener("pjax:complete",init)</script><link rel="stylesheet" href="/css/libs/share.min.css"><script src="/js/libs/share.min.js"></script></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2022</span> - 2025&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">CouriourC</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题 &nbsp; <a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep 3.4.5</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="gg-menu"></i></li><li class="go-comment"><i class="fas fa-comment"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item flex-center tool-font-adjust-plus" title=" 放大 " params=""><i class="fas fa-search-plus"></i></li><li class="tools-item flex-center tool-font-adjust-minus" title=" 缩小 " params=""><i class="fas fa-search-minus"></i></li><li class="tools-item flex-center tool-expand-width" title=" 缩小 " params=""><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item flex-center tool-dark-light-toggle" title=" 切换灯光 " params=""><i class="fas fa-moon"></i></li><li class="tools-item flex-center tool-github-contact-me" title=" 找到我 " params="https://github.com/couriourc/"><i class="fas fa-gg-bot gg-bot"></i></li><li class="tools-item flex-center tool-scroll-to-top" title=" 回到最上 " params=""><i class="fas fa-arrow-up"></i></li><li class="tools-item flex-center tool-scroll-to-bottom" title=" 滚动至最底 " params=""><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">进程同步的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="nav-number">1.1.</span> <span class="nav-text">临界资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-number">2.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5"><span class="nav-number">3.</span> <span class="nav-text">互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-number">3.1.</span> <span class="nav-text">互斥的原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.</span> <span class="nav-text">临界区互斥的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">单标志法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">双标志先检查法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">双标志后检查法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#peterson-%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.</span> <span class="nav-text">Peterson 算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.</span> <span class="nav-text">硬件实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E6%96%B9%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">中断屏蔽方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">5.1.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">5.1.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tsltestandset%E6%8C%87%E4%BB%A4"><span class="nav-number">5.2.</span> <span class="nav-text">TSL(TestAndSet)指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-2"><span class="nav-number">5.3.</span> <span class="nav-text">优点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="nav-number">5.3.1.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swap-%E6%8C%87%E4%BB%A4"><span class="nav-number">5.4.</span> <span class="nav-text">Swap 指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">6.</span> <span class="nav-text">🔒锁（自旋锁🔒）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-3"><span class="nav-number">6.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="nav-number">6.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">7.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">7.1.</span> <span class="nav-text">整型信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">7.2.</span> <span class="nav-text">记录型信号量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-%E4%BA%92%E6%96%A5"><span class="nav-number">8.</span> <span class="nav-text">用信号量实现进程同步、互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="nav-number">8.1.</span> <span class="nav-text">进程互斥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">8.2.</span> <span class="nav-text">进程同步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="nav-number">9.</span> <span class="nav-text">信号量实现前驱关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B"><span class="nav-number">10.</span> <span class="nav-text">管程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#syntax-of-monitor-in-os%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%AE%A1%E7%A8%8B"><span class="nav-number">10.1.</span> <span class="nav-text">Syntax of monitor in OS（操作系统中的管程）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#characteristics-of-monitors-in-os%E7%AE%A1%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-number">10.2.</span> <span class="nav-text">Characteristics of Monitors in OS（管程的特征）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#components-of-monitor-in-an-operating-system%E7%AE%A1%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">10.3.</span> <span class="nav-text">Components of Monitor in an operating system(管程的组成)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#condition-variables%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">10.4.</span> <span class="nav-text">Condition Variables（条件变量）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">10.5.</span> <span class="nav-text">与信号量方法的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#advantages-of-monitor-in-os"><span class="nav-number">10.6.</span> <span class="nav-text">Advantages of Monitor in OS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#disadvantages-of-monitor-in-os"><span class="nav-number">10.7.</span> <span class="nav-text">Disadvantages of Monitor in OS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#conclusion"><span class="nav-number">10.8.</span> <span class="nav-text">Conclusion</span></a></li></ol></li></ol></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/dark-light-toggle.js"></script><script src="/js/local-search.js"></script><script src="/js/code-copy.js"></script><script src="/js/lazyload.js"></script><div class="post-scripts pjax"><script src="/js/left-side-toggle.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/toc.js"></script></div><script src="/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script><script src="/js/libs/tailwind.min.js"></script><script id="__bs_script__">!function(){try{var e=document.createElement("script");e.async=!0,e.src="http://HOST:3000/browser-sync/browser-sync-client.js?v=2.29.3".replace("HOST",location.hostname),document.body?document.body.appendChild(e):document.head&&document.head.appendChild(e)}catch(e){console.error("Browsersync: could not append script tag",e)}}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>