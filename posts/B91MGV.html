<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="CouriourC"><title>函数式编程 | CouriourC Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/avatar.jpg"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"example.com",root:"/",language:"zh-CN",path:"search.xml"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0,init_open:!1},style:{primary_color:"#0066CC",avatar:"/images/avatar.jpg",favicon:"/images/avatar.jpg",article_img_align:"left",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"在天冷的时候总会穿上秋裤"},scroll:{progress_bar:{enable:!0},percent:{enable:!0}}},local_search:{enable:!0,preload:!1},code_copy:{enable:!0,style:"default"},pjax:{enable:!0},lazyload:{enable:!0},version:"3.4.5"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><style type="text/css">.spoiler{display:inline-flex}p.spoiler{display:flex}.spoiler a{pointer-events:none}.spoiler-blur,.spoiler-blur>*{transition:text-shadow .5s ease}.spoiler .spoiler-blur,.spoiler .spoiler-blur>*{color:transparent;background-color:rgba(0,0,0,0);text-shadow:0 0 10px grey;cursor:pointer}.spoiler .spoiler-blur:hover,.spoiler .spoiler-blur:hover>*{text-shadow:0 0 5px grey}.spoiler-box,.spoiler-box>*{transition:color .5s ease,background-color .5s ease}.spoiler .spoiler-box,.spoiler .spoiler-box>*{color:#000;background-color:#000;text-shadow:none}</style><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="小客栈" type="application/atom+xml"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fas fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/"><img src="/images/avatar.jpg"> </a><a class="logo-title" href="/">CouriourC Blog</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item search search-popup-trigger"><i class="gg-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="gg-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">函数式编程</span></div><div class="article-header"><div class="avatar"><img src="/images/avatar.jpg"></div><div class="info"><div class="author"><span class="name">CouriourC</span> <span class="author-label">Lv5</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp; <span class="pc">2024-12-31 22:45:02</span> <span class="mobile">2024-12-31 22:45</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>&nbsp;</li><li>&gt; <a href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/">编程范式</a>&nbsp;</li></ul></span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="一句话简述"><a class="markdownIt-Anchor" href="#一句话简述"></a> 一句话简述</h2><p>函数式函数式编程，是一种从数据流和数据关系的思考方式，可读性强且安全。<strong>Pay attention!!!</strong> 函数表示一切，包括数字。</p><h2 id="约定"><a class="markdownIt-Anchor" href="#约定"></a> 约定</h2><p>本文使用 <code>Dart</code> 语言描述，对于编程范式，具体是什么语言并不重要，只是顺手而已。</p><h2 id="为什么需要函数式编程"><a class="markdownIt-Anchor" href="#为什么需要函数式编程"></a> 为什么需要函数式编程</h2><h3 id="可预测-bug-少"><a class="markdownIt-Anchor" href="#可预测-bug-少"></a> 可预测、Bug 少</h3><p>函数式编程中，以函数为载体，数据流为驱动，数据是<strong>不允许篡改</strong>的，数据的操作是<strong>公开的</strong>，数据的流动是<strong>可预测</strong>的。这样就能很好的规避竞态问题。</p><h3 id="易于测试"><a class="markdownIt-Anchor" href="#易于测试"></a> 易于测试</h3><p>以函数为叙述单元，只需要知道数据的来源，对于数据的返回值是，正如之前所说，可预测的数据流，那么就很容易将用例拆分，从而做到测试。</p><h3 id="移植性高"><a class="markdownIt-Anchor" href="#移植性高"></a> 移植性高</h3><p>函数为思考主体，从而做到模块化。</p><h2 id="函数式编程是什么"><a class="markdownIt-Anchor" href="#函数式编程是什么"></a> 函数式编程是什么</h2><p>根据维基百科所述，<strong>函数式编程</strong>(又叫做<strong>函数程序设计</strong>、<strong>泛函编程</strong>、<strong>Functional Programing</strong>)，是一种编程范式，它将<a class="link" target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E9%81%8B%E7%AE%97" title="电脑运算">电脑运算<i class="fas fa-external-link-alt"></i></a>视为<a class="link" target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0" title="函数">函数<i class="fas fa-external-link-alt"></i></a>运算，并且避免使用程序[状态]( <a class="link" target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E7%8A%B6%E6%80%81_">https://zh.wikipedia.org/w/index.php?title=状态_<i class="fas fa-external-link-alt"></i></a> (%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&amp;action=edit&amp;redlink=1)以及<a class="link" target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8F%AF%E8%AE%8A%E7%89%A9%E4%BB%B6" title="不可变物件">可变物件<i class="fas fa-external-link-alt"></i></a>。从定义出发，有两个关键点：</p><ul><li>函数运算。<br>在 <strong>函数式编程</strong>中，函数就是头等公民，你可以将函数名当作变量赋值给其他变量，使用方式不受影响。比如</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 定义一个减法</span></span><br><span class="line">  <span class="built_in">int</span> minus(<span class="built_in">int</span> a,<span class="built_in">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义一个加法</span></span><br><span class="line">  <span class="keyword">var</span> add = (<span class="built_in">int</span> a,<span class="built_in">int</span> b)=&gt;a+b;</span><br><span class="line">  <span class="comment">// 将 minus 赋值给另外一个变量</span></span><br><span class="line">  <span class="keyword">var</span> minusTwo = minus;</span><br><span class="line">  <span class="comment">// 使用函数</span></span><br><span class="line">  <span class="built_in">print</span>(add(<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">// 输出 3</span></span><br><span class="line">  <span class="built_in">print</span>(minus_2(<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">// 输出 -1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>状态及可变性管理。<br><strong>函数式编程</strong>中的特点是，纯函数，所谓纯函数是指相同的输入总会得到相同的输出，并且不会产生副作用的函数。</li></ul><p>这和数学中的关注点一样 <code>f(data) = (other_state_data)</code>，也就是 <code>dataIn</code>，<code>dataOut</code>，这个之间只是来自于我们的函数作用不同，进一步请关联一下数学中基本的函数基础，<code>单调性</code>、<code>对称性</code>、<code>复合函数</code>、甚至是一些其他复杂的概念，这是<strong>函数的切入点</strong>。<strong>数据的切入点</strong>则可以理解<strong>数据流</strong>，数据如同水流一样，在奔向大海的途中，有阻碍，有汇入，但是本质还是那一堆水的映射。所谓副作用，就是不污染全局，但是接受闭包。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的作用域</span></span><br><span class="line"><span class="keyword">var</span> globalVarity = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">dirty()&#123;</span><br><span class="line">	<span class="comment">// 污染全局变量</span></span><br><span class="line">	globalVarity++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 又一个函数调用</span></span><br><span class="line">dirtyTwo()&#123;</span><br><span class="line">	globalVarity++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 那么在并发的时候,Opps 你猜是什么，这还是微任务的情况下，是可预见的。</span></span><br><span class="line">main()&#123;</span><br><span class="line">  <span class="keyword">while</span> ( globalVarity &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">0</span>),()&#123;</span><br><span class="line">      dirty();</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;for 1 <span class="subst">$globalVarity</span>&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">0</span>),()&#123;</span><br><span class="line">      dirtyTwo();</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;for 2 <span class="subst">$globalVarity</span>&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 篡改</span></span><br><span class="line">    globalVarity++;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 面目全非的 globalVarity;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数式编程与其他范式的区别"><a class="markdownIt-Anchor" href="#函数式编程与其他范式的区别"></a> 函数式编程与其他范式的区别</h2><h3 id="面向过程编程"><a class="markdownIt-Anchor" href="#面向过程编程"></a> 面向过程编程</h3><p>命令式编程，就是 <code>one by one</code>，这种思考方式偏向于原子化，经典的例子：把大象关进冰箱需要几步。面向对象的描述方式是说，第一步，打开冰箱，第二步装入冰箱，第三步关上冰箱。</p><h3 id="面向对象编程"><a class="markdownIt-Anchor" href="#面向对象编程"></a> 面向对象编程</h3><p>面向对象编程，将操作方式进行分类，让动作属于某一个对象，然后进行架构。依然以关大象举例，大象打开了冰箱（对象作用），大象走进了冰箱，大象关上了门。</p><h3 id="声明式编程-面向字典编程"><a class="markdownIt-Anchor" href="#声明式编程-面向字典编程"></a> 声明式编程 (面向字典编程 🧠)</h3><p>声明式编程，一切都已经安排好了，是一套预定的规则，比如 <code>CSS</code>，你只需要加上合适的属性，就能完成编程，底层已经为您做了实现。还是以上面关大象为例子，大象可以被装进冰箱，冰箱可以装大象。然后声明，大象在冰箱中。</p><h2 id="函数式编程起源λ-演算"><a class="markdownIt-Anchor" href="#函数式编程起源λ-演算"></a> 函数式编程起源：λ 演算</h2><p>λ 演算和图灵机等价（图灵完备，作为一种研究语言又很方便）。<br><img lazyload src="/images/loading.svg" data-src="media/m_086f2492cf70a9fe779091729ec91ce7_r.png" alt=""><br>所以 λ 演算式就三个要点：</p><ol><li><p>绑定关系。变量任意性，x、y 和 z 都行，它仅仅是具体数据的代称。</p></li><li><p>递归定义。λ 项递归定义，M 可以是一个 λ 项。</p></li><li><p>替换归约。λ 项可应用，空格分隔表示对 M 应用 N，N 可以是一个 λ 项。</p></li></ol><p>比如这样的演算式：<br><img lazyload src="/images/loading.svg" data-src="media/m_adee8c7c0fd29cba78632e5886d62b1c_r.png" alt=""></p><p><img lazyload src="/images/loading.svg" data-src="media/m_776f70e1187ddf8aaf49366f539b2ccd_r.png" alt=""><br>上面的演算式表示有一个函数 f 和一个参数 x。令 0 为 x，1 为 f x，2 为 f f x…，这就像我们数学中的幂：a^x（a 的 x 次幂表示 a 对自身乘 x 次）。相应的，我们理解上面的演算式就是数字 n 就是 f 对 x 作用的次数。有了这个数字的定义之后，我们就可以在这个基础上定义运算。</p><p>对应到我们前端使用的结果其实就是</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 0 在函数中理解为不作为，就是什么都不做</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">zero</span> = f=&gt;<span class="function"><span class="params">x</span>=&gt;</span>x;</span><br><span class="line"><span class="comment">// 进入了一个层级</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">one</span> = f=&gt;<span class="function"><span class="params">x</span>=&gt;</span><span class="title function_">f</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义加法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">n,m</span>)=&gt;<span class="function"><span class="params">f</span>=&gt;</span><span class="function">()=&gt;</span><span class="title function_">m</span>(f)(<span class="title function_">n</span>(f)())</span><br><span class="line"><span class="comment">// 那么 2 就是</span></span><br><span class="line"><span class="keyword">const</span> two = <span class="title function_">add</span>(one,one)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给2传一个函数,会打印2次:</span></span><br><span class="line"><span class="title function_">two</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;print 2 times&#x27;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算数字3 = 1 + 2:</span></span><br><span class="line"><span class="keyword">let</span> three = <span class="title function_">add</span>(one, two);</span><br><span class="line"><span class="title function_">three</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;print 3 times&#x27;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在函数式编程的世界中，一切皆函数，函数是一等公民。一等公民这个名字听起来很高大上，但是也相当晦涩，这个词也不是翻译的不好，因为英文原文中叫 first class citizen 很多人包括我也不知所云。其实所谓一等公民，它的意思是函数与基本数据类型一样，可作为函数的入参，也可作为函数的返回值，函数可以赋值给变量。我们知道在平常的命令式编程语言中（例如 Java）中，函数的返回值比较简单，只能是基本数据类型（整型，布尔，字符串等）或者是一个 Object。而在 JavaScript 函数是第一公民，因此我们也可以在函数中返回函数。正因为有了这种属性，函数的入参可以是函数，函数的返回值可以是函数，于是便有了高阶函数，以及各种骚操作和一些看起来很炫酷的语法糖。可以说函数为第一公民是函数式编程的必要条件。</p><h2 id="前端中常见的-fp-概念"><a class="markdownIt-Anchor" href="#前端中常见的-fp-概念"></a> 前端中常见的 FP 概念</h2><p>From Functional Programming Jargon(opens new window)</p><ul><li>Higher-Order Functions (HOF)：高阶函数</li><li>Closure：闭包（数学集合中的概念）</li><li>Currying：柯里化</li><li>Function Composition：函数组合</li><li>Pure Function：纯函数</li><li>Side effects：副作用</li><li>Point-Free Style：隐式参数</li><li>Functor：函子</li><li>Lambda Calculus：Lambda 演算</li><li>Lazy evaluation：惰性求值</li></ul><h2 id="ramdajs"><a class="markdownIt-Anchor" href="#ramdajs"></a> <a class="link" target="_blank" rel="noopener" href="https://ramdajs.com/">Ramdajs<i class="fas fa-external-link-alt"></i></a></h2><p>Ramda 主要特性如下：</p><ol><li>Ramda 强调更加纯粹的函数式风格。数据不变性和函数无副作用是其核心设计理念。这可以帮助你使用简洁、优雅的代码来完成工作。</li><li>Ramda 函数本身都是自动柯里化的。这可以让你在只提供部分参数的情况下，轻松地在已有函数的基础上创建新函数。</li><li>Ramda 函数参数的排列顺序更便于柯里化。要操作的数据通常在最后面。</li></ol><p><img lazyload src="/images/loading.svg" data-src="media/m_7918f55fbfb67840cfe5c7028ede8c32_r.png" alt=""></p><h3 id="ramda-中有关-fp-概念的-api"><a class="markdownIt-Anchor" href="#ramda-中有关-fp-概念的-api"></a> Ramda 中有关 FP 概念的 API</h3><ul><li>partial</li><li>curry</li><li>lift</li><li>compose/pipe</li></ul><h2 id="rxjs"><a class="markdownIt-Anchor" href="#rxjs"></a> RxJS</h2><p>RxJS 是一个库，它通过使用 observable 序列来编写异步和基于事件的程序。它提供了一个核心类型 Observable，附属类型 (Observer、 Schedulers、 Subjects) 和受 [Array#extras] 启发的操作符 (map、filter、reduce、every, 等等)，这些数组操作符可以把异步事件作为集合来处理。</p><p>在 RxJS 中用来解决异步事件管理的的基本概念是：</p><ul><li>Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。</li><li>Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。</li><li>Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。</li><li>Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。</li><li>Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。</li><li>Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其他。</li></ul><p><img lazyload src="/images/loading.svg" data-src="media/m_fb4fc77e2fa5edbf80257209da9f9601_r.png" alt=""></p></div><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/posts/3S4RX0V.html"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">Task</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/posts/3CPDVQ4.html"><span class="title flex-center"><span class="post-nav-title-item">实践中的算法</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comment-anchor"></div><div class="comment-area-title"><i class="fas fa-comments">&nbsp;评论</i></div><div id="gitalk-container"></div><script data-pjax src="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script><script data-pjax>function loadGitalk(){let e=decodeURI(location.pathname);50<e.length&&(e=e.substring(0,47)+"...");try{Gitalk&&new Gitalk({clientID:"89b09c1ace1068a64740",clientSecret:"a790fd5655b56ce21a8462dc286b9e913592d742",repo:"couriourc.blog_talk",owner:"couriourc",admin:["couriourc"],id:e,language:"zh-CN"}).render("gitalk-container")}catch(e){window.Gitalk=null}}{const e=setTimeout(()=>{loadGitalk(),clearTimeout(e)},1e3)}</script></div></div></div></div><div class="social-share w-full flex-center" data-sites="weibo, qq, qzone,wechat"></div><script>let mermaidLoad=document.createElement("script");function init(){document.head.append(mermaidLoad),setTimeout(()=>{mermaid?.initialize({})})}mermaidLoad.src="https://unpkg.com/mermaid@9.1.2/dist/mermaid.min.js",mermaidLoad.addEventListener("load",init),document.addEventListener("pjax:complete",init)</script><link rel="stylesheet" href="/css/libs/share.min.css"><script src="/js/libs/share.min.js"></script></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2022</span> - 2025&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">CouriourC</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题 &nbsp; <a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep 3.4.5</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="gg-menu"></i></li><li class="go-comment"><i class="fas fa-comment"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item flex-center tool-font-adjust-plus" title=" 放大 " params=""><i class="fas fa-search-plus"></i></li><li class="tools-item flex-center tool-font-adjust-minus" title=" 缩小 " params=""><i class="fas fa-search-minus"></i></li><li class="tools-item flex-center tool-expand-width" title=" 缩小 " params=""><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item flex-center tool-dark-light-toggle" title=" 切换灯光 " params=""><i class="fas fa-moon"></i></li><li class="tools-item flex-center tool-github-contact-me" title=" 找到我 " params="https://github.com/couriourc/"><i class="fas fa-gg-bot gg-bot"></i></li><li class="tools-item flex-center tool-scroll-to-top" title=" 回到最上 " params=""><i class="fas fa-arrow-up"></i></li><li class="tools-item flex-center tool-scroll-to-bottom" title=" 滚动至最底 " params=""><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%AE%80%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">一句话简述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A6%E5%AE%9A"><span class="nav-number">2.</span> <span class="nav-text">约定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">为什么需要函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%A2%84%E6%B5%8B-bug-%E5%B0%91"><span class="nav-number">3.1.</span> <span class="nav-text">可预测、Bug 少</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%93%E4%BA%8E%E6%B5%8B%E8%AF%95"><span class="nav-number">3.2.</span> <span class="nav-text">易于测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E6%A4%8D%E6%80%A7%E9%AB%98"><span class="nav-number">3.3.</span> <span class="nav-text">移植性高</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">4.</span> <span class="nav-text">函数式编程是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%85%B6%E4%BB%96%E8%8C%83%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">函数式编程与其他范式的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">5.1.</span> <span class="nav-text">面向过程编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="nav-number">5.2.</span> <span class="nav-text">面向对象编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B-%E9%9D%A2%E5%90%91%E5%AD%97%E5%85%B8%E7%BC%96%E7%A8%8B"><span class="nav-number">5.3.</span> <span class="nav-text">声明式编程 (面向字典编程 🧠)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%B5%B7%E6%BA%90%CE%BB-%E6%BC%94%E7%AE%97"><span class="nav-number">6.</span> <span class="nav-text">函数式编程起源：λ 演算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84-fp-%E6%A6%82%E5%BF%B5"><span class="nav-number">7.</span> <span class="nav-text">前端中常见的 FP 概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ramdajs"><span class="nav-number">8.</span> <span class="nav-text">Ramdajs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ramda-%E4%B8%AD%E6%9C%89%E5%85%B3-fp-%E6%A6%82%E5%BF%B5%E7%9A%84-api"><span class="nav-number">8.1.</span> <span class="nav-text">Ramda 中有关 FP 概念的 API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rxjs"><span class="nav-number">9.</span> <span class="nav-text">RxJS</span></a></li></ol></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/dark-light-toggle.js"></script><script src="/js/local-search.js"></script><script src="/js/code-copy.js"></script><script src="/js/lazyload.js"></script><div class="post-scripts pjax"><script src="/js/left-side-toggle.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/toc.js"></script></div><script src="/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script><script src="/js/libs/tailwind.min.js"></script><script id="__bs_script__">!function(){try{var e=document.createElement("script");e.async=!0,e.src="http://HOST:3000/browser-sync/browser-sync-client.js?v=2.29.3".replace("HOST",location.hostname),document.body?document.body.appendChild(e):document.head&&document.head.appendChild(e)}catch(e){console.error("Browsersync: could not append script tag",e)}}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>