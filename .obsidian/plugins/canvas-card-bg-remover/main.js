/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CCBgRemoverPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var CSSClassAll = "ccbgrm-plugin";
var CSSClassImage = "ccbgrm-plugin-img";
var CSSClassCanvas = "ccbgrm-plugin-cnvs";
var CSSClassMarkdown = "ccbgrm-plugin-md";
var CSSClassMap = {
  "image-embed": CSSClassImage,
  "canvas-embed": CSSClassCanvas,
  "markdown-embed": CSSClassMarkdown
};
var ImageNode = {
  type: "image-embed",
  display: "Image",
  cls: CSSClassImage
};
var CanvasNode = {
  type: "canvas-embed",
  display: "Canvas",
  cls: CSSClassCanvas
};
var MarkdownNode = {
  type: "markdown-embed",
  display: "Markdown",
  cls: CSSClassMarkdown
};
var AllEmbeds = [ImageNode, CanvasNode, MarkdownNode];
var DEFAULT_SETTINGS = {
  applyAllEmbed: false,
  targets: [ImageNode, CanvasNode]
};
var CCBgRemoverPlugin = class extends import_obsidian.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
  }
  clearStyle() {
    this.app.workspace.containerEl.removeClasses([
      CSSClassAll,
      CSSClassImage,
      CSSClassCanvas,
      CSSClassMarkdown
    ]);
  }
  generateStyle() {
    if (this.settings.applyAllEmbed) {
      this.app.workspace.containerEl.addClass(CSSClassAll);
    } else {
      const clsList = this.settings.targets.map(
        (item) => {
          return item.cls ? item.cls : CSSClassMap[item.type];
        }
      );
      this.app.workspace.containerEl.addClasses(clsList);
    }
  }
  async onload() {
    this.context = { plugin: this };
    await this.loadSettings();
    this.addSettingTab(new CCBgRemoverPluginSettingsTab(this.app, this));
    this.applySettings();
  }
  async applySettings() {
    this.clearStyle();
    this.generateStyle();
  }
  onunload() {
    this.clearStyle();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  saveAndReload() {
    this.saveSettings().then(() => {
      this.applySettings();
    }, () => {
    });
  }
};
var CCBgRemoverPluginSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  _refreshTargetFields() {
    const p = this.plugin;
    if (p.settings.applyAllEmbed) {
      for (const field of this.allTargetFields) {
        field.setDisabled(true);
        field.settingEl.style.setProperty("savedDisplay", field.settingEl.style.display);
        field.settingEl.style.display = "none";
      }
    } else {
      for (const field of this.allTargetFields) {
        field.setDisabled(false);
        field.settingEl.style.display = field.settingEl.style.getPropertyValue("savedDisplay");
      }
    }
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const p = this.plugin;
    const targetSet = new import_obsidian.Setting(containerEl);
    targetSet.setName("Cards");
    const applyAll = new import_obsidian.Setting(containerEl);
    applyAll.setName("Apply to all cards");
    applyAll.addToggle((comp) => {
      comp.setValue(p.settings.applyAllEmbed);
      comp.onChange((value) => {
        p.settings.applyAllEmbed = value;
        this._refreshTargetFields();
        p.saveAndReload();
      });
    });
    this.allTargetFields = [];
    for (const target of AllEmbeds) {
      const isEnabled = this.hasType(target, p.settings.targets);
      const setting = new import_obsidian.Setting(containerEl);
      setting.setName(target.display);
      setting.addToggle((comp) => {
        comp.setValue(isEnabled);
        comp.onChange((value) => {
          if (value) {
            if (!this.hasType(target, p.settings.targets)) {
              p.settings.targets.push(target);
              p.saveAndReload();
            }
          } else {
            if (this.hasType(target, p.settings.targets)) {
              p.settings.targets.splice(this.indexInArr(target, p.settings.targets), 1);
              p.saveAndReload();
            }
          }
        });
      });
      this.allTargetFields.push(setting);
    }
    this._refreshTargetFields();
    const labelsDesc = new import_obsidian.Setting(containerEl);
    labelsDesc.setName("How to change the label's visibility");
    labelsDesc.setDesc("Change it in the Settings > Canvas > Display Card Label");
  }
  hasType(target, arr) {
    return this.indexInArr(target, arr) >= 0;
  }
  indexInArr(target, arr) {
    return arr.findIndex((value, index) => {
      return value.type === target.type;
    });
  }
};
