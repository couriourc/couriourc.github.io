/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BetterMarkdownCommentsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/utility/appearanceUtils.ts
function buildStyleString(appearance) {
  const { backgroundColor, showBackground, color, fontTheme, customFont, italic, weight, showOutline, outlineColor } = appearance;
  const props = [];
  props.push(`color: ${color}`);
  props.push(`font-weight: ${weight}`);
  italic && props.push("font-style: italic");
  showBackground && props.push(`background-color: ${backgroundColor}`);
  showOutline && props.push(
    `text-shadow: ${outlineColor} -1px -1px 1px, ${outlineColor} 1px -1px 1px, ${outlineColor} -1px 1px 1px, ${outlineColor} 1px 1px 1px`
  );
  switch (fontTheme) {
    case "default":
      break;
    case "monospace":
      props.push("font-family: monospace");
      break;
    case "custom":
      props.push(`font-family: ${customFont}`);
      break;
  }
  return props.join("; ");
}

// src/settings/language.ts
var languages = {
  applescript: {
    commentStart: "--",
    commentEnd: ""
  },
  arduino: {
    commentStart: "//",
    commentEnd: ""
  },
  bash: {
    commentStart: "#",
    commentEnd: ""
  },
  basic: {
    commentStart: "'",
    commentEnd: ""
  },
  c: {
    commentStart: "//",
    commentEnd: ""
  },
  cpp: {
    commentStart: "//",
    commentEnd: ""
  },
  csharp: {
    commentStart: "//",
    commentEnd: ""
  },
  cs: {
    commentStart: "//",
    commentEnd: ""
  },
  css: {
    commentStart: "/*",
    commentEnd: "*/"
  },
  d: {
    commentStart: "//",
    commentEnd: ""
  },
  dart: {
    commentStart: "//",
    commentEnd: ""
  },
  elixir: {
    commentStart: "#",
    commentEnd: ""
  },
  elm: {
    commentStart: "--",
    commentEnd: ""
  },
  erlang: {
    commentStart: "%",
    commentEnd: ""
  },
  fsharp: {
    commentStart: "//",
    commentEnd: ""
  },
  gdscript: {
    commentStart: "#",
    commentEnd: ""
  },
  glsl: {
    commentStart: "//",
    commentEnd: ""
  },
  go: {
    commentStart: "//",
    commentEnd: ""
  },
  gradle: {
    commentStart: "//",
    commentEnd: ""
  },
  graphql: {
    commentStart: "#",
    commentEnd: ""
  },
  groovy: {
    commentStart: "//",
    commentEnd: ""
  },
  haskell: {
    commentStart: "--",
    commentEnd: ""
  },
  hs: {
    commentStart: "--",
    commentEnd: ""
  },
  html: {
    commentStart: "<!--",
    commentEnd: "-->"
  },
  java: {
    commentStart: "//",
    commentEnd: ""
  },
  javascript: {
    commentStart: "//",
    commentEnd: ""
  },
  js: {
    commentStart: "//",
    commentEnd: ""
  },
  jsx: {
    commentStart: "//",
    commentEnd: ""
  },
  // Technically not allowed, but we'll provide it anyway
  json: {
    commentStart: "//",
    commentEnd: ""
  },
  julia: {
    commentStart: "#",
    commentEnd: ""
  },
  kotlin: {
    commentStart: "//",
    commentEnd: ""
  },
  kt: {
    commentStart: "//",
    commentEnd: ""
  },
  latex: {
    commentStart: "%",
    commentEnd: ""
  },
  less: {
    commentStart: "/*",
    commentEnd: "*/"
  },
  lisp: {
    commentStart: ";",
    commentEnd: ""
  },
  lua: {
    commentStart: "--",
    commentEnd: ""
  },
  markdown: {
    commentStart: "<!--",
    commentEnd: "-->"
  },
  md: {
    commentStart: "<!--",
    commentEnd: "-->"
  },
  mermaid: {
    commentStart: "%%",
    commentEnd: ""
  },
  nim: {
    commentStart: "#",
    commentEnd: ""
  },
  objc: {
    commentStart: "//",
    commentEnd: ""
  },
  objectivec: {
    commentStart: "//",
    commentEnd: ""
  },
  pascal: {
    commentStart: "//",
    commentEnd: ""
  },
  perl: {
    commentStart: "#",
    commentEnd: ""
  },
  php: {
    commentStart: "//",
    commentEnd: ""
  },
  protobuf: {
    commentStart: "//",
    commentEnd: ""
  },
  python: {
    commentStart: "#",
    commentEnd: ""
  },
  py: {
    commentStart: "#",
    commentEnd: ""
  },
  r: {
    commentStart: "#",
    commentEnd: ""
  },
  rb: {
    commentStart: "#",
    commentEnd: ""
  },
  ruby: {
    commentStart: "#",
    commentEnd: ""
  },
  rust: {
    commentStart: "//",
    commentEnd: ""
  },
  sass: {
    commentStart: "/*",
    commentEnd: "*/"
  },
  scala: {
    commentStart: "//",
    commentEnd: ""
  },
  scss: {
    commentStart: "/*",
    commentEnd: "*/"
  },
  sh: {
    commentStart: "#",
    commentEnd: ""
  },
  shell: {
    commentStart: "#",
    commentEnd: ""
  },
  smalltalk: {
    commentStart: '"',
    commentEnd: '"'
  },
  sql: {
    commentStart: "--",
    commentEnd: ""
  },
  swift: {
    commentStart: "//",
    commentEnd: ""
  },
  toml: {
    commentStart: "#",
    commentEnd: ""
  },
  ts: {
    commentStart: "//",
    commentEnd: ""
  },
  tsx: {
    commentStart: "//",
    commentEnd: ""
  },
  typescript: {
    commentStart: "//",
    commentEnd: ""
  },
  wasm: {
    commentStart: ";;",
    commentEnd: ""
  },
  wgsl: {
    commentStart: "//",
    commentEnd: ""
  },
  xml: {
    commentStart: "<!--",
    commentEnd: "-->"
  },
  yaml: {
    commentStart: "#",
    commentEnd: ""
  },
  yml: {
    commentStart: "#",
    commentEnd: ""
  },
  zig: {
    commentStart: "//",
    commentEnd: ""
  }
};
var Languages = new Map(Object.entries(languages));

// src/utility/editorUtils.ts
var import_language = require("@codemirror/language");
function extractEditorView(editor) {
  return editor.cm;
}
var CODE_LANG_REGEX = /^```(.*)$/;
function findCodeLang(editor, line) {
  var _a, _b;
  const view = extractEditorView(editor);
  const linePos = view.state.doc.line(line + 1).from;
  const cursor = (0, import_language.syntaxTree)(view.state).cursorAt(linePos, 1);
  if (!cursor.type.name.contains("hmd-codeblock")) {
    return null;
  }
  let found = false;
  let { from, to } = cursor;
  while (line > 0) {
    line--;
    const linePos2 = view.state.doc.line(line + 1).from;
    const cursor2 = (0, import_language.syntaxTree)(view.state).cursorAt(linePos2, 1);
    if (!cursor2.type.name.contains("hmd-codeblock")) {
      found = true;
      break;
    }
    from = cursor2.from;
    to = cursor2.to;
  }
  if (!found) {
    return null;
  }
  const text = view.state.sliceDoc(from, to);
  const matches = CODE_LANG_REGEX.exec(text);
  return (_b = (_a = matches == null ? void 0 : matches.at(1)) == null ? void 0 : _a.trim()) != null ? _b : null;
}
function isMathBlock(editor, line) {
  const view = extractEditorView(editor);
  const linePos = view.state.doc.line(line + 1).from;
  const cursor = (0, import_language.syntaxTree)(view.state).cursorAt(linePos, 1);
  return cursor.type.name.contains("math") || cursor.type.name.contains("comment_math");
}
function containsMathBlockTokens(editor, line) {
  const view = extractEditorView(editor);
  const linePos = view.state.doc.line(line + 1);
  for (let pos = linePos.from; pos < linePos.to; pos++) {
    const cursor = (0, import_language.syntaxTree)(view.state).cursorAt(pos, 1);
    if (cursor.type.name.contains("begin_keyword_math_math-block") || cursor.type.name.contains("end_keyword_math_math-block")) {
      return true;
    }
  }
  return false;
}

// src/utility/commentUtils.ts
function getCommentTokens(settings, lang) {
  if (lang) {
    for (const { commentEnd, commentStart, regex } of settings.customLanguages) {
      if (regex.trim().length === 0) {
        continue;
      }
      if (new RegExp(regex, "i").test(lang)) {
        return [commentStart, commentEnd];
      }
    }
    const standard = Languages.get(lang);
    if (standard) {
      return [standard.commentStart, standard.commentEnd];
    }
    return ["", ""];
  }
  switch (settings.commentStyle) {
    case "html":
      return ["<!--", "-->"];
    case "obsidian":
      return ["%%", "%%"];
    case "custom":
      return [settings.customCommentStart, settings.customCommentEnd];
    default:
      throw new Error(`Unknown comment kind: ${settings.commentStyle}`);
  }
}
function buildCommentString(text, commentStart, commentEnd) {
  const end = commentEnd ? ` ${commentEnd}` : "";
  return `${commentStart} ${text}${end}`;
}
function shouldDenyComment(editor, line) {
  const text = editor.getLine(line).trim();
  return text.length === 0 || text.startsWith("```") || text.startsWith("$$") || containsMathBlockTokens(editor, line);
}

// src/utility/generalUtils.ts
function escapeRegex(text) {
  return text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function comparePos(a, b) {
  if (a.line < b.line) {
    return -1 /* Less */;
  }
  if (a.line > b.line) {
    return 1 /* Greater */;
  }
  if (a.ch < b.ch) {
    return -1 /* Less */;
  }
  if (a.ch > b.ch) {
    return 1 /* Greater */;
  }
  return 0 /* Equal */;
}

// src/utility/ListDict.ts
var ListDict = class _ListDict {
  /**
   *
   * @param toKey The function to use to generate the key for an item
   * @param entries The initial entries to populate the list with
   */
  constructor(toKey, entries) {
    this.toKey = toKey;
    this.list = entries ? Array.from(entries) : [];
    this.dict = new Map(this.list.map((item, i) => [toKey(item), i]));
  }
  /**
   * Create a {@link ListDict} that uses the item itself as the key.
   */
  static identity(entries) {
    return new _ListDict((item) => item, entries);
  }
  /**
   * The length of the list.
   */
  get length() {
    return this.list.length;
  }
  [Symbol.iterator]() {
    return this.list[Symbol.iterator]();
  }
  /**
   * Get the item with the given key.
   */
  get(key) {
    const index = this.dict.get(key);
    return index === void 0 ? void 0 : this.list[index];
  }
  /**
   * Get the item at the given index.
   */
  at(index) {
    return this.list[index];
  }
  /**
   * Get the index of the given item.
   */
  indexOf(item) {
    return this.dict.get(item);
  }
  /**
   * Push an item to the end of the list.
   */
  push(item) {
    const index = this.list.push(item) - 1;
    this.dict.set(this.toKey(item), index);
    return index;
  }
  /**
   * Remove and return the last item in the list.
   */
  pop() {
    const item = this.list.pop();
    if (item) {
      this.dict.delete(this.toKey(item));
    }
    return item;
  }
  /**
   * Insert an item at the given index.
   */
  insert(index, item) {
    if (index < 0 || index > this.list.length) {
      return false;
    }
    this.list.splice(index, 0, item);
    this.dict.set(this.toKey(item), index);
    this.updateIndexes(index + 1);
    return true;
  }
  /**
   * Remove the item with the given key.
   */
  remove(item) {
    const index = this.dict.get(item);
    if (index === void 0) {
      return false;
    }
    this.list.splice(index, 1);
    this.dict.delete(item);
    this.updateIndexes(index);
    return true;
  }
  /**
   * Remove the item at the given index.
   */
  removeAt(index) {
    const item = this.list[index];
    if (item === void 0) {
      return false;
    }
    this.list.splice(index, 1);
    this.dict.delete(this.toKey(item));
    return true;
  }
  /**
   * Swap the positions of two items.
   *
   * @param itemA The key of the first item
   * @param itemB The key of the second item
   */
  swap(itemA, itemB) {
    const indexA = this.dict.get(itemA);
    const indexB = this.dict.get(itemB);
    if (indexA === void 0 || indexB === void 0) {
      return false;
    }
    return this.swapAt(indexA, indexB);
  }
  /**
   * Swap the positions of two items.
   *
   * @param indexA The index of the first item
   * @param indexB The index of the second item
   */
  swapAt(indexA, indexB) {
    const itemA = this.list[indexA];
    const itemB = this.list[indexB];
    if (itemA === void 0 || itemB === void 0) {
      return false;
    }
    this.list[indexA] = itemB;
    this.list[indexB] = itemA;
    this.dict.set(this.toKey(itemA), indexB);
    this.dict.set(this.toKey(itemB), indexA);
    return true;
  }
  /**
   * Remove all items from the list.
   */
  clear() {
    const length = this.list.length;
    this.list.length = 0;
    this.dict.clear();
    return length;
  }
  /**
   * Create a new array populated with the results of calling a provided function
   * on every element in the list.
   */
  map(mapper, thisArg) {
    return this.list.map(mapper, thisArg);
  }
  /**
   * Update all the mapped indexes after the given index.
   */
  updateIndexes(startIndex = 0) {
    for (let i = startIndex; i < this.length; i++) {
      const item = this.at(i);
      if (item === void 0) {
        continue;
      }
      this.dict.set(this.toKey(item), i);
    }
  }
};

// src/utility/animation/AnimationGroup.ts
var AnimationGroup = class {
  constructor(...effects) {
    var _a;
    this.keyframes = Array(effects.length);
    let maxDuration = -Infinity;
    for (const effect of effects) {
      const duration = (_a = Number(effect.getTiming().duration)) != null ? _a : 0;
      if (duration > maxDuration) {
        this.longestKeyframe = effect;
        maxDuration = duration;
      }
      this.keyframes.push(effect);
    }
  }
  /**
   * Plays all animations in the group.
   * @param callback A callback that is called when the longest animation finishes.
   */
  play(callback = null) {
    const isReducedMotion = matchMedia("(prefers-reduced-motion: reduce)").matches;
    for (const keyframe of this.keyframes) {
      const animation = new Animation(keyframe);
      if (this.longestKeyframe === keyframe) {
        animation.onfinish = callback;
      }
      if (isReducedMotion) {
        animation.finish();
      } else {
        animation.play();
      }
    }
  }
};

// src/utility/animation/defaults.ts
var AnimationOptions = {
  get fastEaseOut() {
    return {
      duration: 150,
      easing: "ease-out"
    };
  },
  get fasterEaseOut() {
    return {
      duration: 50,
      easing: "ease-out"
    };
  },
  get debugEaseOut() {
    return {
      duration: 2500,
      easing: "ease-out"
    };
  }
};

// src/toggle/controller.ts
var LineCommentController = class {
  constructor(editor, settings) {
    this.editor = editor;
    this.settings = settings;
    /**
     * The set of uncommitted changes that have been made by this controller.
     */
    this.changes = [];
  }
  /**
   * Take the uncommitted changes that have been made by this controller.
   *
   * This will drain the list, leaving it empty and ready for future use.
   */
  takeChanges() {
    const changes = this.changes;
    this.changes = [];
    return changes;
  }
  /**
   * Toggle the comment state of the given line.
   */
  toggle(line, options = {}) {
    const original = this.editor.getLine(line);
    const indent = Math.max(original.search(/\S/), 0);
    const { state, commentStart, commentEnd } = this.lineState(line);
    const { isCommented, text } = state;
    if (commentStart.length === 0 && commentEnd.length === 0) {
      return { before: state, after: state, commentStart, commentEnd };
    }
    if (isCommented) {
      if (options.forceComment) {
        return { before: state, after: state, commentStart, commentEnd };
      }
      this.addChange(line, text, indent);
      return { before: state, after: { isCommented: false, text }, commentStart, commentEnd };
    } else {
      const newText = buildCommentString(text, commentStart, commentEnd);
      this.addChange(line, newText, indent);
      return {
        before: state,
        after: { isCommented: true, text: newText },
        commentStart,
        commentEnd
      };
    }
  }
  /**
   * Get the current comment state of the given range.
   */
  rangeState(fromLine, toLine) {
    let rangeState = null;
    for (let line = fromLine; line <= toLine; line++) {
      if (shouldDenyComment(this.editor, line)) {
        continue;
      }
      const { isCommented } = this.lineState(line).state;
      switch (rangeState) {
        case null:
          rangeState = isCommented ? "commented" : "uncommented";
          break;
        case "commented":
          rangeState = isCommented ? "commented" : "mixed";
          break;
        case "uncommented":
          rangeState = isCommented ? "mixed" : "uncommented";
          break;
        case "mixed":
          break;
      }
    }
    return rangeState;
  }
  /**
   * Get the current comment state of the given line.
   */
  lineState(line) {
    const [commentStart, commentEnd] = this.getLineCommentTokens(line);
    const regex = this.buildCommentRegex(commentStart, commentEnd);
    const text = this.editor.getLine(line);
    const matches = regex.exec(text);
    if (matches === null) {
      return { state: { isCommented: false, text: text.trim() }, commentStart, commentEnd };
    }
    const innerText = matches[1];
    return { state: { isCommented: true, text: innerText.trim() }, commentStart, commentEnd };
  }
  getLineCommentTokens(line) {
    if (isMathBlock(this.editor, line)) {
      return ["%", ""];
    }
    const lang = findCodeLang(this.editor, line);
    return getCommentTokens(this.settings, lang);
  }
  /**
   * Build a regex that matches the comment tokens according to the line's context and
   * current {@link Settings}.
   *
   * Contains one unnamed capture group containing the text between the comment tokens.
   */
  buildCommentRegex(commentStart, commentEnd) {
    const start = escapeRegex(commentStart);
    const end = escapeRegex(commentEnd);
    return new RegExp(`${start}\\s*(.*)\\s*${end}`);
  }
  /**
   * Add a change to the list of changes to be applied to the editor.
   *
   * @param line The affected line.
   * @param text The new text for the line.
   * @param indent The indent of the line (i.e. where to insert the text).
   */
  addChange(line, text, indent = 0) {
    return this.changes.push({
      from: { line, ch: indent },
      to: { line, ch: this.editor.getLine(line).length },
      text
    });
  }
};

// src/settings/defaults.ts
var DEFAULT_SETTINGS = {
  overrideAppearance: false,
  commentStyle: "html",
  customCommentStart: "<!--",
  customCommentEnd: "-->",
  dropCursor: false,
  appearance: {
    showBackground: false,
    backgroundColor: "#191919",
    color: "#565E67",
    fontTheme: "default",
    customFont: "initial",
    italic: false,
    weight: 400,
    showOutline: false,
    outlineColor: "#FFFFFF"
  },
  customLanguages: []
};
function emptyLang() {
  return {
    regex: "",
    commentStart: "",
    commentEnd: ""
  };
}

// src/settings/tab.ts
var import_obsidian4 = require("obsidian");

// src/settings/utils.ts
function getSetting(settings, path) {
  const parts = path.split(".");
  let obj = settings;
  for (const part of parts) {
    obj = obj[part];
  }
  return obj;
}
function setSetting(settings, path, value) {
  const parts = path.split(".");
  const key = parts.pop();
  if (key === void 0) {
    throw new Error("Invalid settings path");
  }
  let obj = settings;
  for (const part of parts) {
    obj = obj[part];
  }
  obj[key] = value;
}
function restoreSettings(settings, ...paths) {
  for (const path of paths) {
    const value = getSetting(DEFAULT_SETTINGS, path);
    setSetting(settings, path, value);
  }
}
function isDefaultSettings(settings, ...paths) {
  for (const path of paths) {
    const defaultValue = getSetting(DEFAULT_SETTINGS, path);
    const currentValue = getSetting(settings, path);
    if (defaultValue !== currentValue) {
      return false;
    }
  }
  return true;
}

// src/settings/styles.scss
var styles_default = {
  "code": "_code_1fg9r_1",
  "comment": "_comment_1fg9r_8",
  "disabled": "_disabled_1fg9r_12",
  "heading": "_heading_1fg9r_18",
  "codeBlockSection": "_code-block-section_1fg9r_26",
  "customLanguageList": "_customLanguageList_1fg9r_30",
  "addButton": "_add-button_1fg9r_33",
  "card": "_card_1fg9r_37",
  "hideTopBorder": "_hide-top-border_1fg9r_44",
  "empty": "_empty_1fg9r_48"
};

// src/styles.scss
var styles_default2 = {
  "code": "_code_7lx45_1",
  "comment": "_comment_7lx45_8",
  "disabled": "_disabled_7lx45_12"
};

// src/components/CustomLanguageBlock.ts
var import_obsidian3 = require("obsidian");

// src/components/CustomLanguageBlock.module.scss
var CustomLanguageBlock_module_default = {
  "code": "_code_1afh3_1",
  "comment": "_comment_1afh3_8",
  "disabled": "_disabled_1afh3_12",
  "container": "_container_1afh3_18",
  "foldout": "_foldout_1afh3_33",
  "summarySection": "_summary-section_1afh3_44",
  "regex": "_regex_1afh3_55",
  "regexIcon": "_regex-icon_1afh3_64",
  "regexText": "_regex-text_1afh3_72",
  "sample": "_sample_1afh3_83",
  "fields": "_fields_1afh3_90",
  "fieldName": "_field-name_1afh3_98",
  "field": "_field_1afh3_90",
  "buttons": "_buttons_1afh3_109",
  "controlButton": "_control-button_1afh3_126",
  "addButton": "_add-button_1afh3_135",
  "mobileAdd": "_mobile-add_1afh3_138",
  "addButtonHidden": "_add-button-hidden_1afh3_157"
};

// src/components/Foldout.module.scss
var Foldout_module_default = {
  "foldout": "_foldout_mlqh5_2",
  "summary": "_summary_mlqh5_6",
  "content": "_content_mlqh5_30"
};

// src/components/BaseComponent.ts
var BaseComponent = class {
  constructor(container) {
    this.rootEl = this.init(container);
  }
  /**
   * Add one or more classes to the root element of this component.
   * @param cls
   */
  addClass(...cls) {
    this.rootEl.addClass(...cls);
    return this;
  }
};

// src/components/Foldout.ts
var Foldout = class extends BaseComponent {
  init(container) {
    const root = container.createEl("details", Foldout_module_default.foldout);
    this.summaryEl = root.createEl("summary", Foldout_module_default.summary);
    this.contentEl = root.createDiv(Foldout_module_default.content);
    return root;
  }
  setSummary(summary) {
    if (typeof summary === "string") {
      this.summaryEl.append(summary);
      return this;
    }
    this.summaryEl.append(typeof summary === "function" ? summary() : summary);
    return this;
  }
  addChild(child) {
    this.contentEl.appendChild(typeof child === "function" ? child() : child);
    return this;
  }
};

// src/components/TextInput.ts
var import_obsidian = require("obsidian");

// src/components/TextInput.module.scss
var TextInput_module_default = {
  "container": "_container_jdwya_1",
  "name": "_name_jdwya_6"
};

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");

// src/components/TextInput.ts
var TextInput = class extends BaseComponent {
  init(container) {
    const root = container.createDiv(TextInput_module_default.container);
    const id = nanoid();
    this.nameEl = root.createEl("label", { cls: TextInput_module_default.name, attr: { for: id } });
    this.textComponent = new import_obsidian.TextComponent(root);
    this.textComponent.inputEl.id = id;
    return root;
  }
  get disabled() {
    return this.textComponent.disabled;
  }
  get inputEl() {
    return this.textComponent.inputEl;
  }
  setName(name) {
    this.nameEl.setText(name);
    return this;
  }
  getValue() {
    return this.textComponent.getValue();
  }
  onChange(callback) {
    this.textComponent.onChange(callback);
    return this;
  }
  onChanged() {
    this.textComponent.onChanged();
  }
  registerOptionListener(listeners, key) {
    this.textComponent.registerOptionListener(listeners, key);
    return this;
  }
  setDisabled(disabled) {
    this.textComponent.setDisabled(disabled);
    return this;
  }
  setPlaceholder(placeholder) {
    this.textComponent.setPlaceholder(placeholder);
    return this;
  }
  setValue(value) {
    this.textComponent.setValue(value);
    return this;
  }
  then(cb) {
    cb(this);
    return this;
  }
};

// src/components/IconButton.ts
var import_obsidian2 = require("obsidian");

// src/components/IconButton.module.scss
var IconButton_module_default = {
  "btn": "_btn_1v12z_1"
};

// src/components/IconButton.ts
var IconButton = class extends import_obsidian2.ExtraButtonComponent {
  constructor(containerEl) {
    super(containerEl);
    this.extraSettingsEl.role = "button";
    this.extraSettingsEl.tabIndex = 0;
    this.extraSettingsEl.addClass(IconButton_module_default.btn);
    this.extraSettingsEl.addEventListener("keypress", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        this.extraSettingsEl.click();
      }
    });
  }
  setDisabled(disabled) {
    this.extraSettingsEl.toggleClass(styles_default2.disabled, disabled);
    this.extraSettingsEl.setAttr("aria-disabled", disabled);
    return super.setDisabled(disabled);
  }
};

// src/components/CustomLanguageBlock.ts
var CustomLanguageBlock = class extends BaseComponent {
  init(container) {
    this.lang = emptyLang();
    const block = container.createDiv(CustomLanguageBlock_module_default.container);
    new Foldout(block).setSummary(() => {
      const frag = new DocumentFragment();
      const summary = frag.createEl("figure", CustomLanguageBlock_module_default.summarySection);
      const regexContainer = summary.createEl("figcaption", CustomLanguageBlock_module_default.regex);
      const icon = regexContainer.createDiv(CustomLanguageBlock_module_default.regexIcon);
      (0, import_obsidian3.setIcon)(icon, "regex");
      icon.role = "img";
      this.regexEl = regexContainer.createDiv(CustomLanguageBlock_module_default.regexText);
      this.sampleEl = summary.createSpan({
        cls: [CustomLanguageBlock_module_default.sample, CustomLanguageBlock_module_default.code, CustomLanguageBlock_module_default.comment]
      });
      return frag;
    }).addChild(() => {
      const frag = new DocumentFragment();
      const content = frag.createDiv(CustomLanguageBlock_module_default.fields);
      this.regexInputComponent = new TextInput(content).setName("Regex").setPlaceholder("lang");
      this.regexInputComponent.inputEl.addClass(CustomLanguageBlock_module_default.field);
      this.startInputComponent = new TextInput(content).setName("Comment Start").setPlaceholder("<!--");
      this.startInputComponent.inputEl.addClass(CustomLanguageBlock_module_default.field);
      this.endInputComponent = new TextInput(content).setName("Comment End").setPlaceholder("-->");
      this.endInputComponent.inputEl.addClass(CustomLanguageBlock_module_default.field);
      return frag;
    }).rootEl.addClass(CustomLanguageBlock_module_default.foldout);
    const buttons = block.createDiv(CustomLanguageBlock_module_default.buttons);
    this.upBtnComponent = new IconButton(buttons).setIcon("chevron-up").setTooltip("Shift up");
    this.upBtnComponent.extraSettingsEl.addClass(CustomLanguageBlock_module_default.controlButton);
    this.downBtnComponent = new IconButton(buttons).setIcon("chevron-down").setTooltip("Shift down");
    this.downBtnComponent.extraSettingsEl.addClass(CustomLanguageBlock_module_default.controlButton);
    this.deleteBtnComponent = new IconButton(buttons).setIcon("x").setTooltip("Delete");
    this.deleteBtnComponent.extraSettingsEl.addClass(CustomLanguageBlock_module_default.controlButton);
    this.addBtnComponents = [];
    const mobileAddBtn = new IconButton(buttons).setIcon("plus").setTooltip("Insert");
    mobileAddBtn.extraSettingsEl.addClass(CustomLanguageBlock_module_default.addButton, CustomLanguageBlock_module_default.controlButton, CustomLanguageBlock_module_default.mobileAdd);
    const normalAddBtn = new IconButton(block).setIcon("plus").setTooltip("Insert");
    normalAddBtn.extraSettingsEl.addClass(CustomLanguageBlock_module_default.addButton);
    this.addBtnComponents = [mobileAddBtn, normalAddBtn];
    return block;
  }
  setLang(lang) {
    this.lang = lang;
    const { regex, commentStart, commentEnd } = lang;
    this.regexInputComponent.setValue(regex);
    this.regexEl.setText(regex);
    this.startInputComponent.setValue(commentStart);
    this.endInputComponent.setValue(commentEnd);
    this.sampleEl.setText(`${commentStart} This is a comment ${commentEnd}`);
    return this;
  }
  onChange(callback) {
    this.regexInputComponent.onChange((value) => {
      this.lang.regex = value.trim();
      this.setLang(this.lang);
      callback(this.lang, this);
    });
    this.startInputComponent.onChange((value) => {
      this.lang.commentStart = value.trim();
      this.setLang(this.lang);
      callback(this.lang, this);
    });
    this.endInputComponent.onChange((value) => {
      this.lang.commentEnd = value.trim();
      this.setLang(this.lang);
      callback(this.lang, this);
    });
    return this;
  }
  onShiftUp(callback) {
    this.upBtnComponent.onClick(() => callback(this));
    return this;
  }
  onShiftDown(callback) {
    this.downBtnComponent.onClick(() => callback(this));
    return this;
  }
  onDelete(callback) {
    this.deleteBtnComponent.onClick(() => callback(this));
    return this;
  }
  onAdd(callback) {
    for (const component of this.addBtnComponents) {
      component.onClick(() => callback(this));
    }
    return this;
  }
  setShiftUpDisabled(disabled) {
    this.upBtnComponent.setDisabled(disabled);
    return this;
  }
  setShiftDownDisabled(disabled) {
    this.downBtnComponent.setDisabled(disabled);
    return this;
  }
  setDeleteDisabled(disabled) {
    this.deleteBtnComponent.setDisabled(disabled);
    return this;
  }
  setAddButtonHidden(hidden) {
    for (const component of this.addBtnComponents) {
      component.extraSettingsEl.toggleAttribute("disabled", hidden);
      component.extraSettingsEl.toggleClass(CustomLanguageBlock_module_default.addButtonHidden, hidden);
    }
    return this;
  }
};

// src/components/CustomLanguageList.module.scss
var CustomLanguageList_module_default = {
  "list": "_list_wi5e1_1",
  "item": "_item_wi5e1_5"
};

// src/components/CustomLanguageList.ts
var CustomLanguageList = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.onChangeCallback = () => {
    };
  }
  init(container) {
    const root = container.createEl("ol", CustomLanguageList_module_default.list);
    this.items = new ListDict((item) => item.el);
    return root;
  }
  languages() {
    return this.items.map((item) => item.lang);
  }
  setLanguages(languages2) {
    this.items.clear();
    for (const lang of languages2) {
      this.pushLang(lang);
    }
    return this;
  }
  onChange(callback) {
    this.onChangeCallback = callback;
    return this;
  }
  pushLang(lang) {
    this.insert(this.items.length, lang);
    return this;
  }
  /**
   * Create and insert a new language block at the given index.
   *
   * @param index The index to insert the new block at.
   * If undefined, the block will be inserted at the end of the list.
   * @param language The language of the block.
   * If undefined, sets the block to an empty language.
   */
  insert(index, language) {
    index = index != null ? index : this.items.length;
    const el = this.rootEl.createEl("li", CustomLanguageList_module_default.item);
    const lang = language != null ? language : emptyLang();
    const block = new CustomLanguageBlock(el).setLang(lang).onChange((lang2, self) => {
      self.setLang(lang2);
      this.onChangeCallback(this.languages());
    }).onAdd(() => {
      const index2 = this.items.indexOf(el);
      if (index2 === void 0) {
        return;
      }
      this.insert(index2 + 1);
      this.onChangeCallback(this.languages());
    }).onShiftUp(() => {
      this.shift(el, "up");
      this.onChangeCallback(this.languages());
    }).onShiftDown(() => {
      this.shift(el, "down");
      this.onChangeCallback(this.languages());
    }).onDelete(() => {
      this.remove(el);
      this.onChangeCallback(this.languages());
    });
    const item = { el, block, lang };
    if (this.rootEl.childNodes.length > 0 && index > 0) {
      const curr = this.rootEl.childNodes.item(index);
      curr.before(item.el);
    }
    this.items.insert(index, item);
    this.refreshIndexes(index - 1, index, index + 1);
    new AnimationGroup(
      new KeyframeEffect(
        item.el,
        [
          {
            // from
            opacity: "0",
            height: "0",
            transform: "scaleY(0)"
          },
          {
            // to
            opacity: "1",
            height: `${item.el.clientHeight}px`,
            transform: "scaleY(1)"
          }
        ],
        AnimationOptions.fasterEaseOut
      )
    ).play();
  }
  remove(item) {
    const index = this.items.indexOf(item);
    if (index === void 0) {
      return;
    }
    this.items.remove(item);
    this.refreshFirstAndLast();
    new AnimationGroup(
      new KeyframeEffect(
        item,
        [
          {
            // from
            opacity: "1",
            height: `${item.clientHeight}px`,
            transform: "scaleY(1)"
          },
          {
            // to
            opacity: "0",
            height: "0",
            transform: "scaleY(0)"
          }
        ],
        AnimationOptions.fasterEaseOut
      )
    ).play(() => {
      item.remove();
    });
  }
  shift(el, direction) {
    const index = this.items.indexOf(el);
    if (index === void 0 || index === 0 && direction === "up" || index === this.items.length - 1 && direction === "down") {
      return;
    }
    const offset = direction === "up" ? -1 : 1;
    const item = this.items.at(index);
    const sibling = this.items.at(index + offset);
    const [first, second] = direction === "up" ? [item, sibling] : [sibling, item];
    this.items.swap(first.el, second.el);
    this.refreshItems(first.el, second.el);
    new AnimationGroup(
      new KeyframeEffect(
        first.el,
        [
          {
            // from
            transform: "translateY(0)"
          },
          {
            // to
            transform: `translateY(-${second.el.offsetHeight}px)`
          }
        ],
        AnimationOptions.fastEaseOut
      ),
      new KeyframeEffect(
        second.el,
        [
          {
            // from
            transform: "translateY(0)"
          },
          {
            // to
            transform: `translateY(${first.el.offsetHeight}px)`
          }
        ],
        AnimationOptions.fastEaseOut
      )
    ).play(() => {
      const active = this.rootEl.doc.activeElement;
      this.rootEl.insertBefore(first.el, second.el);
      active.focus();
    });
  }
  /**
   * Refresh the first and last list items.
   *
   * This will update the rendered state of the items in the DOM.
   *
   * This is a convenience around {@link refreshIndexes} to be used whenever
   * only the first and last items need to be refreshed.
   */
  refreshFirstAndLast() {
    if (this.items.length === 0) {
      return;
    }
    this.refreshItems(this.items.at(0).el);
    if (this.items.length === 1) {
      return;
    }
    this.refreshItems(this.items.at(this.items.length - 1).el);
  }
  /**
   * Refresh the given list items.
   *
   * This will update the rendered state of the items in the DOM.
   */
  refreshItems(...els) {
    for (const el of els) {
      const index = this.items.indexOf(el);
      if (index === void 0) {
        continue;
      }
      this.refreshIndexes(index);
    }
  }
  /**
   * Refresh the list items at the given indexes.
   *
   * This will update the rendered state of the items in the DOM.
   */
  refreshIndexes(...indexes) {
    for (const index of indexes) {
      if (index < 0 || index >= this.items.length) {
        continue;
      }
      const item = this.items.at(index);
      if (item === void 0) {
        continue;
      }
      const { block } = item;
      block.setShiftUpDisabled(index === 0);
      block.setShiftDownDisabled(index === this.items.length - 1);
      block.setAddButtonHidden(index === this.items.length - 1);
    }
  }
};

// src/components/Text.ts
var Text = class extends BaseComponent {
  constructor(container, text = "", variant = "setting-item-description") {
    super(container);
    this.variant = variant;
    this.setText(text);
    this.setVariant(variant);
  }
  init(container) {
    return container.createDiv();
  }
  setText(text) {
    this.rootEl.setText(computeText(text));
    return this;
  }
  setVariant(variant) {
    this.rootEl.removeClass(this.variant);
    this.variant = variant;
    this.rootEl.addClass(variant);
    return this;
  }
};
function computeText(text) {
  return typeof text === "function" ? text(new DocumentFragment()) : text;
}

// src/settings/tab.ts
var SettingsTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.containerStack = [this.containerEl];
  }
  display() {
    this.container.empty();
    this.container.createEl("h1", { text: "General", cls: styles_default.heading });
    this.createGeneralSection();
    this.container.createEl("h1", { text: "Appearance", cls: styles_default.heading });
    this.createExampleSection();
    this.createAppearanceSection();
    this.container.createEl("h1", { text: "Code Blocks", cls: styles_default.heading });
    this.createCodeBlockSection();
  }
  /**
   * The currently active container element in the {@link containerStack}.
   *
   * This should be preferred over {@link containerEl} when adding any element
   * as it will always reflect the active container.
   */
  get container() {
    return this.containerStack[this.containerStack.length - 1];
  }
  createGeneralSection() {
    this.add(
      ["commentStyle"],
      (setting, apply) => {
        const desc = new DocumentFragment();
        desc.appendText("The style of comment to use when toggling.");
        desc.createEl("br");
        desc.createEl("br");
        desc.createEl("span", {
          text: "Note: ",
          attr: { style: "font-weight: var(--font-semibold);" }
        });
        desc.appendText("Changing this value will not update existing comments.");
        return setting.setName("Comment style").setDesc(desc).addDropdown((dropdown) => {
          dropdown.addOptions({
            html: "HTML (<!-- -->)",
            obsidian: "Obsidian (%% %%)",
            custom: "Custom"
          }).setValue(this.plugin.settings.commentStyle).onChange(async (value) => {
            this.plugin.settings.commentStyle = value;
            await apply();
            this.display();
          });
        });
      },
      { refreshAppearance: false }
    );
    if (this.plugin.settings.commentStyle === "custom") {
      this.add(
        ["customCommentStart", "customCommentEnd"],
        (setting, apply) => {
          const desc = new DocumentFragment();
          desc.appendText("The start and end tokens used to comment out a line.");
          desc.createEl("br");
          desc.createEl("br");
          desc.createEl("span", {
            text: "Note: ",
            attr: { style: "font-weight: var(--font-semibold);" }
          });
          desc.appendText(
            "Custom tokens that would not otherwise render as a valid comment in Markdown can still be used but will not be hidden from reader view."
          );
          return setting.setName("Custom comment style").setDesc(desc).addText((text) => {
            text.setPlaceholder('Comment start (e.g. "<!--")').setValue(this.plugin.settings.customCommentStart).onChange(async (value) => {
              this.plugin.settings.customCommentStart = value.trim();
              await apply();
            });
          }).addText(
            (text) => {
              var _a;
              return text.setPlaceholder('Comment end (e.g. "-->")').setValue((_a = this.plugin.settings.customCommentEnd) != null ? _a : "").onChange(async (value) => {
                this.plugin.settings.customCommentEnd = value.trim();
                await apply();
              });
            }
          );
        },
        { refreshAppearance: false }
      );
    }
    this.add(
      ["dropCursor"],
      (setting, apply) => setting.setName("Drop cursor").setDesc("Automatically drop the cursor to the next line after toggling a comment.").addToggle((toggle) => {
        toggle.setValue(this.plugin.settings.dropCursor).onChange(async (value) => {
          this.plugin.settings.dropCursor = value;
          await apply();
        });
      }),
      { refreshAppearance: false }
    );
  }
  createExampleSection() {
    const exampleCard = this.createCard(() => {
      const exampleContainer = this.container.createDiv({
        cls: "cm-line"
      });
      this.example = exampleContainer.createEl("span");
      this.updateExample();
    });
    exampleCard.setAttribute("role", "figure");
    exampleCard.setAttribute("aria-label", "Example of what a comment will look like.");
  }
  createAppearanceSection() {
    const { overrideAppearance, appearance } = this.plugin.settings;
    this.add(
      ["overrideAppearance"],
      (setting, apply) => {
        const elt = setting.setName("Override appearance").setDesc("Allow this plugin to override the current comment appearance.").addToggle((toggle) => {
          toggle.setValue(overrideAppearance).onChange(async (value) => {
            this.plugin.settings.overrideAppearance = value;
            await apply();
            this.display();
          });
        }).settingEl;
        elt.addClass(styles_default.hideTopBorder);
        return setting;
      },
      {
        refreshAppearance: false,
        onApply: () => {
          this.plugin.refreshAppearanceOverride();
        }
      }
    );
    this.createSection(() => {
      const empty = new import_obsidian4.Setting(this.container).setDisabled(true).settingEl;
      empty.addClass(styles_default.empty);
      empty.toggleAttribute("inert", true);
      this.add(
        ["appearance.color"],
        (setting, apply) => setting.setName("Comment color").addColorPicker((picker) => {
          picker.setValue(appearance.color).onChange(async (value) => {
            appearance.color = value;
            await apply();
          });
        })
      ).setDisabled(!overrideAppearance);
      this.add(
        ["appearance.showBackground", "appearance.backgroundColor"],
        (setting, apply) => setting.setName("Comment background").addToggle((toggle) => {
          toggle.setValue(appearance.showBackground).onChange(async (value) => {
            appearance.showBackground = value;
            await apply();
          });
        }).addColorPicker((picker) => {
          picker.setValue(appearance.backgroundColor).onChange(async (value) => {
            appearance.backgroundColor = value;
            await apply();
          });
        })
      ).setDisabled(!overrideAppearance);
      this.add(
        ["appearance.showOutline", "appearance.outlineColor"],
        (setting, apply) => setting.setName("Comment outline").addToggle((toggle) => {
          toggle.setValue(appearance.showOutline).onChange(async (value) => {
            appearance.showOutline = value;
            await apply();
          });
        }).addColorPicker((picker) => {
          picker.setValue(appearance.outlineColor).onChange(async (value) => {
            appearance.outlineColor = value;
            await apply();
          });
        })
      ).setDisabled(!overrideAppearance);
      this.add(["appearance.fontTheme"], (setting, apply) => {
        const desc = new DocumentFragment();
        desc.appendText("The font to use for comments.");
        return setting.setName("Comment font").setDesc(desc).addDropdown((dropdown) => {
          dropdown.addOptions({
            default: "Default",
            monospace: "Monospace",
            custom: "Custom"
          }).setValue(this.plugin.settings.appearance.fontTheme).onChange(async (value) => {
            this.plugin.settings.appearance.fontTheme = value;
            await apply();
            this.display();
          });
        });
      }).setDisabled(!overrideAppearance);
      if (this.plugin.settings.appearance.fontTheme === "custom") {
        this.add(["appearance.customFont"], (setting, apply) => {
          const desc = new DocumentFragment();
          desc.appendText("The font-family to use for comments.");
          return setting.setName("Custom font").setDesc(desc).addText((text) => {
            text.setPlaceholder("Arial, sans-serif").setValue(this.plugin.settings.appearance.customFont).onChange(async (value) => {
              this.plugin.settings.appearance.customFont = value.trim().split(";")[0];
              await apply();
            });
          });
        }).setDisabled(!overrideAppearance);
      }
      this.add(
        ["appearance.italic"],
        (setting, apply) => setting.setName("Italicize comments").addToggle((toggle) => {
          toggle.setValue(appearance.italic).onChange(async (value) => {
            appearance.italic = value;
            await apply();
          });
        })
      ).setDisabled(!overrideAppearance);
      this.add(
        ["appearance.weight"],
        (setting, apply) => setting.setName("Comment font weight").addSlider((slider) => {
          slider.setLimits(100, 900, 100).setDynamicTooltip().setValue(appearance.weight).onChange(async (value) => {
            appearance.weight = value;
            await apply();
          });
        })
      ).setDisabled(!overrideAppearance);
    }, overrideAppearance);
  }
  createCodeBlockSection() {
    this.createSection(() => {
      this.container.addClass(styles_default.codeBlockSection);
      new Text(this.container).setText("Custom languages").setVariant("setting-item-name");
      new Text(this.container).setText((frag) => {
        frag.createDiv({
          cls: "setting-item-description",
          text: "Use the list below to define the comment style for custom code block languages."
        });
        frag.createDiv({
          cls: "setting-item-description",
          text: "Languages are defined using case-insensitive regex and are checked in ascending order (first in the list has the highest priority)."
        }).appendText(" The first one to match the language of the code block will be used.");
        return frag;
      }).setVariant("setting-item-description");
      const list = new CustomLanguageList(this.container).setLanguages(this.plugin.settings.customLanguages).onChange(async (languages2) => {
        this.plugin.settings.customLanguages = languages2;
        await this.plugin.saveSettings();
      }).addClass(styles_default.customLanguageList);
      new import_obsidian4.ButtonComponent(this.container).setButtonText("Add Language").onClick(async () => {
        list.pushLang(emptyLang());
        this.plugin.settings.customLanguages.push(emptyLang());
        await this.plugin.saveSettings();
      }).buttonEl.addClass(styles_default.addButton);
    });
  }
  /**
   * Add a setting to the current {@link container} element.
   *
   * This will automatically handle saving the setting and refreshing the appearance.
   * It will also automatically add a reset button to the setting.
   *
   * @param paths The setting path(s) this setting affects.
   * @param init A function to initialize the setting.
   * @param options Custom configuration for the setting.
   */
  add(paths, init, options = {}) {
    const { refreshAppearance = true, onApply } = options;
    const listeners = [];
    const setting = init(new import_obsidian4.Setting(this.container), async () => {
      await this.plugin.saveSettings();
      refreshAppearance && this.plugin.refreshAppearance();
      onApply == null ? void 0 : onApply();
      this.updateExample();
      listeners.forEach((cb) => cb());
    });
    const resetBtn = new IconButton(setting.controlEl).setIcon("reset").setTooltip("Restore default").onClick(async () => {
      restoreSettings(this.plugin.settings, ...paths);
      await this.plugin.saveSettings();
      this.plugin.refreshAppearance();
      this.display();
    });
    const refresh = () => {
      const isDisabled = isDefaultSettings(this.plugin.settings, ...paths);
      resetBtn.setDisabled(isDisabled);
      resetBtn.extraSettingsEl.style.pointerEvents = isDisabled ? "none" : "auto";
      resetBtn.extraSettingsEl.style.filter = isDisabled ? "opacity(0.5)" : "unset";
      resetBtn.extraSettingsEl.setAttr("aria-disabled", isDisabled);
    };
    listeners.push(refresh);
    refresh();
    return setting;
  }
  /**
   * Create a card element.
   */
  createCard(create) {
    const card = this.container.createDiv(styles_default.card);
    this.containerStack.push(card);
    create();
    this.containerStack.pop();
    return card;
  }
  /**
   * Create a section element.
   *
   * This will automatically handle the styling for disabled sections.
   */
  createSection(create, enabled = true) {
    const section = this.container.createDiv();
    section.toggleClass(styles_default2.disabled, !enabled);
    section.setAttribute("aria-disabled", (!enabled).toString());
    section.toggleAttribute("inert", !enabled);
    this.containerStack.push(section);
    create();
    this.containerStack.pop();
    return section;
  }
  /**
   * Update the example comment with the current settings.
   */
  updateExample() {
    if (this.example) {
      const [commentStart, commentEnd] = getCommentTokens(this.plugin.settings, null);
      this.example.textContent = buildCommentString("This is a comment", commentStart, commentEnd);
      this.example.addClass("cm-comment");
      this.plugin.settings.overrideAppearance && this.example.setAttr("style", buildStyleString(this.plugin.settings.appearance));
    }
  }
};

// src/extensions/plugin.ts
var import_view = require("@codemirror/view");
var import_state2 = require("@codemirror/state");
var import_language3 = require("@codemirror/language");

// src/extensions/fields.ts
var import_state = require("@codemirror/state");
var setEnableAppearance = import_state.StateEffect.define();
var enableAppearanceField = import_state.StateField.define({
  create: () => false,
  update: (value, transaction) => {
    for (const effect of transaction.effects) {
      if (effect.is(setEnableAppearance)) {
        return effect.value;
      }
    }
    return value;
  }
});
var setAppearanceSettings = import_state.StateEffect.define();
var appearanceSettingsField = import_state.StateField.define({
  create: () => ({ ...DEFAULT_SETTINGS.appearance }),
  update: (value, transaction) => {
    for (const effect of transaction.effects) {
      if (effect.is(setAppearanceSettings)) {
        value = {
          ...value,
          ...effect.value
        };
      }
    }
    return value;
  }
});

// src/extensions/plugin.ts
var CommentViewPlugin = class _CommentViewPlugin {
  constructor(view) {
    this.decorations = this.buildDecorations(view);
  }
  /**
   * Create the extension for the plugin, with all its required fields.
   */
  static createExtension(settings) {
    return [
      enableAppearanceField.init(() => settings.overrideAppearance),
      appearanceSettingsField.init(() => settings.appearance),
      import_view.ViewPlugin.fromClass(_CommentViewPlugin, {
        decorations: (value) => value.decorations
      })
    ];
  }
  /**
   * Update the appearance settings for the plugin in the given view.
   */
  static updateAppearance(view, appearance) {
    view.dispatch({
      effects: [setAppearanceSettings.of(appearance)]
    });
  }
  /**
   * Update the enabled state for the plugin in the given view.
   */
  static updateEnabled(view, enabled) {
    view.dispatch({
      effects: [setEnableAppearance.of(enabled)]
    });
  }
  update(update) {
    if (update.docChanged || update.viewportChanged) {
      this.decorations = this.buildDecorations(update.view);
      return;
    }
    for (const effect of update.transactions.flatMap((trn) => trn.effects)) {
      if (effect.is(setAppearanceSettings) || effect.is(setEnableAppearance)) {
        this.decorations = this.buildDecorations(update.view);
        return;
      }
    }
  }
  destroy() {
  }
  buildDecorations(view) {
    if (!view.state.field(enableAppearanceField)) {
      return this.emptyDecorationSet;
    }
    const builder = new import_state2.RangeSetBuilder();
    const appearance = view.state.field(appearanceSettingsField);
    const style = buildStyleString(appearance);
    for (const { from, to } of view.visibleRanges) {
      (0, import_language3.syntaxTree)(view.state).iterate({
        from,
        to,
        enter: (node) => {
          if (node.type.name !== "comment") {
            return;
          }
          builder.add(
            node.from,
            node.to,
            import_view.Decoration.mark({
              attributes: {
                style
              }
            })
          );
        }
      });
    }
    return builder.finish();
  }
  get emptyDecorationSet() {
    return new import_state2.RangeSetBuilder().finish();
  }
};

// src/main.ts
var BetterMarkdownCommentsPlugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this));
    this.addCommand({
      id: "toggle",
      icon: "percent",
      name: "Toggle Comment",
      editorCallback: (editor, _view) => {
        this.onToggleComment(editor);
      }
    });
    this.registerEditorExtension(CommentViewPlugin.createExtension(this.settings));
  }
  onunload() {
  }
  async loadSettings() {
    const storedSettings = await this.loadData();
    const defaults = DEFAULT_SETTINGS;
    this.settings = {
      ...defaults,
      ...storedSettings,
      appearance: {
        ...defaults.appearance,
        ...storedSettings == null ? void 0 : storedSettings.appearance
      }
    };
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Refresh the appearance of comments.
   *
   * @see {@link refreshAppearanceOverride} to refresh the override setting.
   */
  refreshAppearance() {
    const editorView = this.activeEditorView;
    if (!editorView) {
      return;
    }
    CommentViewPlugin.updateAppearance(editorView, this.settings.appearance);
  }
  /**
   * Refresh the appearance override of comments.
   *
   * @see {@link refreshAppearance} to refresh the appearance setting.
   */
  refreshAppearanceOverride() {
    const editorView = this.activeEditorView;
    if (!editorView) {
      return;
    }
    CommentViewPlugin.updateEnabled(editorView, this.settings.overrideAppearance);
  }
  get activeEditorView() {
    var _a;
    const editor = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor;
    return editor ? extractEditorView(editor) : void 0;
  }
  onToggleComment(editor) {
    const controller = new LineCommentController(editor, this.settings);
    const from = editor.getCursor("from");
    const to = editor.getCursor("to");
    const anchor = editor.getCursor("anchor");
    const head = editor.getCursor("head");
    const hasSelection = comparePos(anchor, head) !== 0 /* Equal */;
    if (!hasSelection && editor.getLine(from.line).trim().length === 0) {
      const { commentStart } = controller.toggle(from.line);
      editor.transaction({
        changes: controller.takeChanges(),
        selection: {
          from: {
            line: from.line,
            ch: commentStart.length + 1
          }
        }
      });
      return;
    }
    const rangeState = controller.rangeState(from.line, to.line);
    const selection = { anchor, head };
    for (let line = from.line; line <= to.line; line++) {
      if (shouldDenyComment(editor, line)) {
        continue;
      }
      const { before, after, commentStart } = controller.toggle(line, {
        forceComment: !rangeState || rangeState === "mixed"
      });
      const wasChanged = before.isCommented !== after.isCommented;
      const headBefore = { ...selection.head };
      const commentLength = commentStart.length > 0 ? commentStart.length + 1 : 0;
      if (line === anchor.line && wasChanged) {
        selection.anchor.ch = Math.clamp(
          anchor.ch + (after.isCommented ? commentLength : -commentLength),
          0,
          after.text.length
        );
      }
      if (line === head.line && wasChanged) {
        selection.head.ch = Math.clamp(
          head.ch + (after.isCommented ? commentLength : -commentLength),
          0,
          after.text.length
        );
      }
      if (this.settings.dropCursor && !hasSelection && selection.head.line !== editor.lastLine() && commentLength > 0) {
        const text = editor.getLine(line);
        selection.head.line = Math.min(selection.head.line + 1, editor.lastLine());
        selection.head.ch = Math.min(
          // If at start of line -> keep at start of next line
          headBefore.ch === 0 ? 0 : (
            // If at end of line -> keep at end of next line
            headBefore.ch === before.text.length || headBefore.ch === text.length ? Infinity : (
              // If just commented -> account for start comment token
              after.isCommented ? selection.head.ch - commentLength : selection.head.ch
            )
          ),
          editor.getLine(selection.head.line).length
        );
        selection.anchor.line = selection.head.line;
        selection.anchor.ch = selection.head.ch;
      }
    }
    editor.transaction({
      changes: controller.takeChanges(),
      selection: {
        from: selection.anchor,
        to: selection.head
      }
    });
  }
};
