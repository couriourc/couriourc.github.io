---
author: CouriourC
categories: [计算机基础知识]
date: 2022-10-28 14:04:58
dg-publish: false
mathjax: true
sticky: 
tags:
  - 基础知识
  - 数据结构
  - 哈希表
title: 哈希表
typora-root-url: ./数据结构知识点总结-哈希表(散列表)
updated: 2022-10-28 14:04:58
date-created: 2023-03-11
date-modified: 2023-07-09
---

# 哈希表

```plantuml
@startmindmap
* 散列表处理冲突的方法
** 开放选址法<latex>H_i=(H(key)+d_i)\mod m </latex>
** 线性探测法<latex>d_i</latex> 是线性的）
*** 除留余数法
*** <latex>H(key)\mod p</latex> 不大于m最接近m的质数
***_ 发生冲突的时候是 1 2 3 的尝试比较，冲突的时候是模表长
*** 平方探测法/二次探测法（$d_i$ 是平方的）
***_ 发生冲突的时候是 <latex>1, 2^{2}^{2} </latex>的尝试比较，冲突的时候是模表长
** 伪随机序列法
** 再散列法
** 拉链法
@endmindmap
```

## 基本定义

散列表，又叫[哈希表](http://data.biancheng.net/view/63.html)（Hash Table），是能够通过给定的关键字的值直接访问到具体对应的值的一个数据结构。也就是说，把关键字映射到一个表中的位置来直接访问记录，以加快访问速度。

通常，我们把这个关键字称为 Key，把对应的记录称为 Value，所以也可以说是通过 Key 访问一个映射表来得到 Value 的地址。而这个映射表，也叫作散列函数或者哈希函数，存放记录的[数组](http://data.biancheng.net/view/309.html)叫作散列表。

其中有个特殊情况，就是通过不同的 Key，可能访问到同一个地址，这种现象叫作碰撞（Collision）。而通过某个 Key 一定会得到唯一的 Value 地址。

## Hash 函数选取方法

- **直接寻址法**：取关键字或关键字的某个线性函数值为散列地址。
- **数字分析法**：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。
- **平方取中法**：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。
- **取随机数法**：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。
- **除留取余法**：取关键字被某个不大于散列表的表长 $n$ 的数 $m$ 除后所得的余数 $p$ 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 $n$。

## 对散列表函数产生冲突的解决办法

### 开放地址法（也叫开放寻址法）

实际上就是当需要存储值时，对$Key$哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。

### 再哈希法

在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。

### 链地址法

链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个[链表](http://data.biancheng.net/view/298.html)。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的，我们会在后面着重学习这种方式。

### 建立一个公共溢出区

这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。

## 散列表的特点

### 访问速度很快

由于散列表有散列函数，可以将指定的 Key 都映射到一个地址上，所以在访问一个 Key（键）对应的 Value（值）时，根本不需要一个一个地进行查找，可以直接跳到那个地址。所以我们在对散列表进行添加、删除、修改、查找等任何操作时，速度都很快。

### 需要额外的空间

首先，散列表实际上是存不满的，如果一个散列表刚好能够存满，那么肯定是个巧合。而且当散列表中元素的使用率越来越高时，性能会下降，所以一般会选择扩容来解决这个问题。另外，如果有冲突的话，则也是需要额外的空间去存储的，比如链地址法，不但需要额外的空间，甚至需要使用其他数据结构。

这个特点有个很常用的词可以表达，叫作“空间换时间”，在大多数时候，对于算法的实现，为了能够有更好的性能，往往会考虑牺牲些空间，让算法能够更快些。

### 无序

散列表还有一个非常明显的特点，那就是无序。为了能够更快地访问元素，散列表是根据散列函数直接找到存储地址的，这样我们的访问速度就能够更快，但是对于有序访问却没有办法应对。

### 可能会产生碰撞

没有完美的散列函数，无论如何总会产生冲突，这时就需要采用冲突解决方案，这也使散列表更加复杂。通常在不同的高级语言的实现中，对于冲突的解决方案不一定一样。
